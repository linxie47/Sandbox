From c9d90a3f821799f195cdff540a51c21c15f68644 Mon Sep 17 00:00:00 2001
From: Lin Xie <lin.xie@intel.com>
Date: Thu, 11 Jul 2019 10:38:12 +0800
Subject: [PATCH] Introduce image inference backend

Change-Id: I35a3fd0da2e81204ac823b7770ca98be5a562993
---
 configure                                          |   7 +
 libavfilter/Makefile                               |  10 +
 libavfilter/inference_backend/ff_base_inference.c  |  85 ++++
 libavfilter/inference_backend/ff_base_inference.h  | 184 +++++++
 libavfilter/inference_backend/ff_inference_impl.c  | 453 +++++++++++++++++
 libavfilter/inference_backend/ff_inference_impl.h  |  21 +
 libavfilter/inference_backend/ff_list.c            |  79 +++
 libavfilter/inference_backend/ff_list.h            |  41 ++
 libavfilter/inference_backend/ff_pre_proc.c        | 119 +++++
 libavfilter/inference_backend/ff_proc_factory.c    | 187 +++++++
 libavfilter/inference_backend/ff_proc_factory.h    |  13 +
 libavfilter/inference_backend/image.h              |  46 ++
 libavfilter/inference_backend/image_inference.c    | 183 +++++++
 libavfilter/inference_backend/image_inference.h    | 137 ++++++
 libavfilter/inference_backend/logger.c             |  27 ++
 libavfilter/inference_backend/logger.h             |  60 +++
 .../inference_backend/openvino_image_inference.c   | 535 +++++++++++++++++++++
 .../inference_backend/openvino_image_inference.h   |  56 +++
 libavfilter/inference_backend/pre_proc.c           | 118 +++++
 libavfilter/inference_backend/pre_proc.h           |  43 ++
 libavfilter/inference_backend/queue.c              | 151 ++++++
 libavfilter/inference_backend/safe_queue.c         | 145 ++++++
 libavfilter/inference_backend/safe_queue.h         |  28 ++
 23 files changed, 2728 insertions(+)
 create mode 100644 libavfilter/inference_backend/ff_base_inference.c
 create mode 100644 libavfilter/inference_backend/ff_base_inference.h
 create mode 100644 libavfilter/inference_backend/ff_inference_impl.c
 create mode 100644 libavfilter/inference_backend/ff_inference_impl.h
 create mode 100644 libavfilter/inference_backend/ff_list.c
 create mode 100644 libavfilter/inference_backend/ff_list.h
 create mode 100644 libavfilter/inference_backend/ff_pre_proc.c
 create mode 100644 libavfilter/inference_backend/ff_proc_factory.c
 create mode 100644 libavfilter/inference_backend/ff_proc_factory.h
 create mode 100644 libavfilter/inference_backend/image.h
 create mode 100644 libavfilter/inference_backend/image_inference.c
 create mode 100644 libavfilter/inference_backend/image_inference.h
 create mode 100644 libavfilter/inference_backend/logger.c
 create mode 100644 libavfilter/inference_backend/logger.h
 create mode 100644 libavfilter/inference_backend/openvino_image_inference.c
 create mode 100644 libavfilter/inference_backend/openvino_image_inference.h
 create mode 100644 libavfilter/inference_backend/pre_proc.c
 create mode 100644 libavfilter/inference_backend/pre_proc.h
 create mode 100644 libavfilter/inference_backend/queue.c
 create mode 100644 libavfilter/inference_backend/safe_queue.c
 create mode 100644 libavfilter/inference_backend/safe_queue.h

diff --git a/configure b/configure
index f7feedb..9b49d6c 100755
--- a/configure
+++ b/configure
@@ -240,6 +240,7 @@ External library support:
   --enable-libilbc         enable iLBC de/encoding via libilbc [no]
   --enable-libinference_engine enable intel inference engine as a DNN module
                                backend [no]
+  --enable-libinference_engine_c_api enable dldt inference engine c api [no]
   --enable-libjack         enable JACK audio sound server [no]
   --enable-libjson_c       enable libjson-c [no]
   --enable-libklvanc       enable Kernel Labs VANC processing [no]
@@ -1727,6 +1728,7 @@ EXTERNAL_LIBRARY_LIST="
     libiec61883
     libilbc
     libinference_engine
+    libinference_engine_c_api
     libjack
     libjson_c
     libklvanc
@@ -2309,6 +2311,7 @@ CONFIG_EXTRA="
     huffyuvdsp
     huffyuvencdsp
     idctdsp
+    image_inference
     iirfilter
     mdct15
     intrax8
@@ -2552,6 +2555,7 @@ cbs_vp9_select="cbs"
 dct_select="rdft"
 dirac_parse_select="golomb"
 dnn_suggest="libtensorflow libinference_engine"
+image_inference_suggest="libinference_engine_c_api"
 error_resilience_select="me_cmp"
 faandct_deps="faan"
 faandct_select="fdctdsp"
@@ -6262,6 +6266,9 @@ enabled librdkafka  && require_pkg_config librdkafka rdkafka "librdkafka/rdkafka
 
 enabled libjson_c && check_pkg_config libjson_c json-c json-c/json.h json_c_version
 
+enabled libinference_engine_c_api &&
+    require_pkg_config libinference_engine_c_api dldt_c_api "ie_c_api.h" ie_c_api_version
+
 if enabled gcrypt; then
     GCRYPT_CONFIG="${cross_prefix}libgcrypt-config"
     if "${GCRYPT_CONFIG}" --version > /dev/null 2>&1; then
diff --git a/libavfilter/Makefile b/libavfilter/Makefile
index 11f0fb4..24bb09c 100644
--- a/libavfilter/Makefile
+++ b/libavfilter/Makefile
@@ -29,6 +29,16 @@ OBJS-$(CONFIG_QSVVPP)                        += qsvvpp.o
 DNN-OBJS-$(CONFIG_LIBTENSORFLOW)             += dnn_backend_tf.o
 DNN-OBJS-$(CONFIG_LIBINFERENCE_ENGINE)       += dnn_backend_intel_ie.o inference.o
 OBJS-$(CONFIG_DNN)                           += dnn_interface.o dnn_backend_native.o $(DNN-OBJS-yes)
+OBJS-$(CONFIG_IMAGE_INFERENCE)               += inference_backend/ff_base_inference.o        \
+                                                inference_backend/ff_inference_impl.o        \
+                                                inference_backend/ff_list.o                  \
+                                                inference_backend/ff_pre_proc.o              \
+                                                inference_backend/ff_proc_factory.o          \
+                                                inference_backend/image_inference.o          \
+                                                inference_backend/logger.o                   \
+                                                inference_backend/openvino_image_inference.o \
+                                                inference_backend/pre_proc.o                 \
+                                                inference_backend/safe_queue.o               \
 
 # audio filters
 OBJS-$(CONFIG_ABENCH_FILTER)                 += f_bench.o
diff --git a/libavfilter/inference_backend/ff_base_inference.c b/libavfilter/inference_backend/ff_base_inference.c
new file mode 100644
index 0000000..2112f83
--- /dev/null
+++ b/libavfilter/inference_backend/ff_base_inference.c
@@ -0,0 +1,85 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#include "ff_base_inference.h"
+#include "ff_inference_impl.h"
+#include "ff_proc_factory.h"
+#include <libavutil/avassert.h>
+#include <libavutil/mem.h>
+
+FFBaseInference *av_base_inference_create(const char *inference_id) {
+    FFBaseInference *base_inference = (FFBaseInference *)av_mallocz(sizeof(*base_inference));
+
+    base_inference->inference_id = inference_id ? av_strdup(inference_id) : NULL;
+
+    base_inference->param.is_full_frame = TRUE; // default to true
+    base_inference->param.every_nth_frame = 1;  // default to 1
+    base_inference->param.nireq = 1;
+    base_inference->param.batch_size = 1;
+    base_inference->param.threshold = 0.5;
+
+    return base_inference;
+}
+
+int av_base_inference_set_params(FFBaseInference *base, FFInferenceParam *param) {
+    if (!base || !param)
+        return AVERROR(EINVAL);
+
+    if (base->initialized)
+        return 0;
+
+    base->param = *param;
+    base->inference = (void *)FFInferenceImplCreate(base);
+    base->initialized = TRUE;
+    base->post_proc = (void *)getPostProcFunctionByName(base->inference_id, base->param.model);
+
+    return 0;
+}
+
+void av_base_inference_release(FFBaseInference *base) {
+    if (!base)
+        return;
+
+    if (base->inference) {
+        FFInferenceImplRelease((FFInferenceImpl *)base->inference);
+        base->inference = NULL;
+    }
+
+    if (base->inference_id) {
+        av_free((void *)base->inference_id);
+        base->inference_id = NULL;
+    }
+
+    av_free(base);
+}
+
+int av_base_inference_send_frame(void *ctx, FFBaseInference *base, AVFrame *frame_in) {
+    if (!base || !frame_in)
+        return AVERROR(EINVAL);
+
+    return FFInferenceImplAddFrame(ctx, (FFInferenceImpl *)base->inference, frame_in);
+}
+
+int av_base_inference_get_frame(void *ctx, FFBaseInference *base, AVFrame **frame_out) {
+    if (!base || !frame_out)
+        return AVERROR(EINVAL);
+
+    return FFInferenceImplGetFrame(ctx, (FFInferenceImpl *)base->inference, frame_out);
+}
+
+int av_base_inference_frame_queue_empty(void *ctx, FFBaseInference *base) {
+    if (!base)
+        return AVERROR(EINVAL);
+
+    return FFInferenceImplGetQueueSize(ctx, (FFInferenceImpl *)base->inference) == 0 ? TRUE : FALSE;
+}
+
+void av_base_inference_send_event(void *ctx, FFBaseInference *base, FF_INFERENCE_EVENT event) {
+    if (!base)
+        return;
+
+    FFInferenceImplSinkEvent(ctx, (FFInferenceImpl *)base->inference, event);
+}
\ No newline at end of file
diff --git a/libavfilter/inference_backend/ff_base_inference.h b/libavfilter/inference_backend/ff_base_inference.h
new file mode 100644
index 0000000..6916b23
--- /dev/null
+++ b/libavfilter/inference_backend/ff_base_inference.h
@@ -0,0 +1,184 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#pragma once
+
+#include "image_inference.h"
+#include <libavutil/frame.h>
+#include <stdint.h>
+
+typedef enum {
+    INFERENCE_EVENT_NONE,
+    INFERENCE_EVENT_EOS,
+} FF_INFERENCE_EVENT;
+
+#ifndef TRUE
+/** The TRUE value of a UBool @stable ICU 2.0 */
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+/** The FALSE value of a UBool @stable ICU 2.0 */
+#define FALSE 0
+#endif
+
+typedef struct __FFBaseInference FFBaseInference;
+typedef struct __FFInferenceParam FFInferenceParam;
+typedef struct __ProcessedFrame ProcessedFrame;
+typedef struct __InputPreproc InputPreproc;
+typedef struct __OutputPostproc OutputPostproc;
+typedef struct __InputPreproc ModelInputPreproc;
+typedef struct __ModelOutputPostproc ModelOutputPostproc;
+
+#define FF_INFERENCE_OPTIONS                                                                                           \
+    char *model;                                                                                                       \
+    char *object_class;                                                                                                \
+    char *model_proc;                                                                                                  \
+    char *device;                                                                                                      \
+    int batch_size;                                                                                                    \
+    int every_nth_frame;                                                                                               \
+    int nireq;                                                                                                         \
+    char *cpu_streams;                                                                                                 \
+    char *infer_config;                                                                                                \
+    float threshold;
+
+struct __FFInferenceParam {
+    // exposed options
+    FF_INFERENCE_OPTIONS
+
+    int is_full_frame;
+    ModelInputPreproc *model_preproc;
+    ModelOutputPostproc *model_postproc;
+};
+
+struct __FFBaseInference {
+    // unique infer string id
+    const char *inference_id;
+
+    FFInferenceParam param;
+
+    // other fields
+    int initialized;
+    void *inference;        // type: FFInferenceImpl*
+    void *pre_proc;         // type: PreProcFunction
+    void *post_proc;        // type: PostProcFunction
+    void *get_roi_pre_proc; // type: GetROIPreProcFunction
+};
+
+/* ROI for analytics */
+typedef struct __FFVideoRegionOfInterestMeta {
+    char type_name[16];
+
+    unsigned int x;
+    unsigned int y;
+    unsigned int w;
+    unsigned int h;
+} FFVideoRegionOfInterestMeta;
+
+/* model preproc */
+struct __InputPreproc {
+    int color_format;   ///<! input data format
+    char *layer_name;   ///<! layer name of input
+    char *object_class; ///<! interested object class
+};
+
+/* model postproc */
+struct __OutputPostproc {
+    char *layer_name;
+    char *converter;
+    char *attribute_name;
+    char *method;
+    double threshold;
+    double tensor2text_scale;
+    int tensor2text_precision;
+    AVBufferRef *labels;
+};
+
+typedef enum {
+    ANY = 0,
+    NCHW = 1,
+    NHWC = 2,
+} IELayout;
+
+typedef enum {
+    FP32 = 10,
+    U8 = 40,
+} IEPrecision;
+
+#define FF_TENSOR_MAX_RANK 8
+typedef struct _IETensorMeta {
+    IEPrecision precision;           /**< tensor precision */
+    int rank;                        /**< tensor rank */
+    size_t dims[FF_TENSOR_MAX_RANK]; /**< array describing tensor's dimensions */
+    IELayout layout;                 /**< tensor layout */
+    char *layer_name;                /**< tensor output layer name */
+    char *model_name;                /**< model name */
+    void *data;                      /**< tensor data */
+    size_t total_bytes;              /**< tensor size in bytes */
+    const char *element_id;          /**< id of pipeline element that produced current tensor */
+} IETensorMeta;
+
+/* dynamic labels array */
+typedef struct _LabelsArray {
+    char **label;
+    int num;
+} LabelsArray;
+
+typedef struct _InferDetection {
+    float x_min;
+    float y_min;
+    float x_max;
+    float y_max;
+    float confidence;
+    int label_id;
+    int object_id;
+    AVBufferRef *label_buf;
+} InferDetection;
+
+/* dynamic bounding boxes array */
+typedef struct _BBoxesArray {
+    InferDetection **bbox;
+    int num;
+} BBoxesArray;
+
+typedef struct _InferDetectionMeta {
+    BBoxesArray *bboxes;
+} InferDetectionMeta;
+
+typedef struct __InferenceROI {
+    AVFrame *frame;
+    FFVideoRegionOfInterestMeta roi;
+} InferenceROI;
+
+typedef struct __InferenceROIArray {
+    InferenceROI **infer_ROIs;
+    int num_infer_ROIs;
+} InferenceROIArray;
+
+#define MAX_MODEL_OUTPUT 4
+struct __ModelOutputPostproc {
+    OutputPostproc procs[MAX_MODEL_OUTPUT];
+};
+
+typedef void (*PostProcFunction)(const OutputBlobArray *output_blobs, InferenceROIArray *infer_roi_array,
+                                 ModelOutputPostproc *model_postproc, const char *model_name,
+                                 const FFBaseInference *ff_base_inference);
+
+FFBaseInference *av_base_inference_create(const char *inference_id);
+
+int av_base_inference_set_params(FFBaseInference *base, FFInferenceParam *param);
+
+// TODO: add interface to set options separately
+
+void av_base_inference_release(FFBaseInference *base);
+
+int av_base_inference_send_frame(void *ctx, FFBaseInference *base, AVFrame *frame);
+
+int av_base_inference_get_frame(void *ctx, FFBaseInference *base, AVFrame **frame_out);
+
+int av_base_inference_frame_queue_empty(void *ctx, FFBaseInference *base);
+
+void av_base_inference_send_event(void *ctx, FFBaseInference *base, FF_INFERENCE_EVENT event);
diff --git a/libavfilter/inference_backend/ff_inference_impl.c b/libavfilter/inference_backend/ff_inference_impl.c
new file mode 100644
index 0000000..7086d86
--- /dev/null
+++ b/libavfilter/inference_backend/ff_inference_impl.c
@@ -0,0 +1,453 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#include "ff_inference_impl.h"
+#include "ff_base_inference.h"
+#include "ff_list.h"
+#include "image_inference.h"
+#include "logger.h"
+#include <libavutil/avassert.h>
+#include <libavutil/log.h>
+#include <pthread.h>
+
+typedef struct __Model {
+    const char *name;
+    char *object_class;
+    ImageInferenceContext *infer_ctx;
+    FFInferenceImpl *infer_impl;
+    // std::map<std::string, void *> proc;
+    void *input_preproc;
+} Model;
+
+typedef struct __ROIMetaArray {
+    FFVideoRegionOfInterestMeta **roi_metas;
+    int num_metas;
+} ROIMetaArray;
+
+/* \brief output frames stored in queue */
+typedef struct __OutputFrame {
+    AVFrame *frame;
+    AVFrame *writable_frame;
+    int inference_count;
+} OutputFrame;
+
+/* \brief structure taken as IFramPtr carried by \func SubmitImage */
+typedef struct __InferenceResult {
+    InferenceROI inference_frame;
+    Model *model;
+} InferenceResult;
+
+struct __FFInferenceImpl {
+    int frame_num;
+    pthread_mutex_t _mutex; // Maybe not necessary for ffmpeg
+    const FFBaseInference *base_inference;
+
+    Model *model;
+
+    // output frames list
+    pthread_mutex_t output_frames_mutex;
+    ff_list_t *output_frames;
+    ff_list_t *processed_frames; // TODO: consider remove it if all output frames can be consumed instantly
+};
+
+static void SplitString(char *str, const char *delim, char **array, int *num, int max) {
+    char *p;
+    int i = 0;
+
+    if (!str || !delim || !array || !num)
+        return;
+
+    while (p = strtok(str, delim)) {
+        int j = 0;
+        char *s;
+        size_t end;
+
+        /* remove head blanks */
+        while (p[j] == '\n' || p[j] == ' ')
+            j++;
+
+        if (!p[j])
+            continue;
+
+        /* remove tail blanks */
+        s = p + j;
+        end = strlen(s) - 1;
+        while (s[end] == '\n' || s[end] == ' ')
+            s[end--] = '\0';
+
+        array[i++] = s;
+        av_assert0(i < max);
+
+        /* string is cached */
+        str = NULL;
+    }
+
+    *num = i;
+}
+
+static inline int avFormatToFourCC(int format) {
+    switch (format) {
+    case AV_PIX_FMT_NV12:
+        VAII_DEBUG("AV_PIX_FMT_NV12");
+        return FOURCC_NV12;
+    case AV_PIX_FMT_BGR0:
+        VAII_DEBUG("AV_PIX_FMT_BGR0");
+        return FOURCC_BGRX;
+    case AV_PIX_FMT_BGRA:
+        VAII_DEBUG("AV_PIX_FMT_BGRA");
+        return FOURCC_BGRA;
+    case AV_PIX_FMT_BGR24:
+        VAII_DEBUG("AV_PIX_FMT_BGR24");
+        return FOURCC_BGR;
+// #if VA_MAJOR_VERSION >= 1
+    case AV_PIX_FMT_YUV420P:
+        VAII_DEBUG("AV_PIX_FMT_YUV420P");
+        return FOURCC_I420;
+// #endif
+    }
+
+    av_log(NULL, AV_LOG_ERROR, "Unsupported AV Format: %d.", format);
+    return 0;
+}
+
+static void ff_buffer_map(AVFrame *frame, Image *image, MemoryType memoryType) {
+#ifdef DISABLE_VAAPI
+    (void)(memoryType);
+#endif
+    const int n_planes = 4;
+    if (n_planes > MAX_PLANES_NUMBER) {
+        av_log(NULL, AV_LOG_ERROR, "Planes number %d isn't supported.", n_planes);
+        av_assert0(0);
+    }
+
+    image->type = memoryType;
+    image->format = avFormatToFourCC(frame->format);
+    image->width = frame->width;
+    image->height = frame->height;
+    for (int i = 0; i < n_planes; i++) {
+        image->stride[i] = frame->linesize[i];
+    }
+
+#ifndef DISABLE_VAAPI
+    // TODO VAAPI
+#endif
+    {
+        for (int i = 0; i < n_planes; i++) {
+            image->planes[i] = frame->data[i];
+        }
+    }
+}
+
+static int CheckObjectClass(const char *requested, const char *quark) {
+    if (!requested)
+        return 1;
+    // strcmp
+    // return requested == g_quark_to_string(quark);
+    return 1;
+}
+
+static inline void PushOutput(FFInferenceImpl *impl) {
+    ff_list_t *out = impl->output_frames;
+    ff_list_t *processed = impl->processed_frames;
+    while (!out->empty(out)) {
+        OutputFrame *front = (OutputFrame *)out->front(out);
+        AVFrame *frame = front->frame;
+        if (front->inference_count > 0) {
+            break; // inference not completed yet
+        }
+
+        processed->push_back(processed, frame);
+        out->pop_front(out);
+        av_free(front);
+    }
+}
+
+static void InferenceCompletionCallback(OutputBlobArray *blobs, UserDataBuffers *user_data) {
+    Model *model = NULL;
+    FFInferenceImpl *impl = NULL;
+    InferenceResult *result = NULL;
+    const FFBaseInference *base = NULL;
+    InferenceROIArray inference_frames_array = {};
+
+    if (0 == user_data->num_buffers)
+        return;
+
+    result = (InferenceResult *)user_data->frames[0];
+    model = result->model;
+    impl = model->infer_impl;
+    base = impl->base_inference;
+
+    for (int i = 0; i < user_data->num_buffers; i++) {
+        result = (InferenceResult *)user_data->frames[i];
+        av_dynarray_add(&inference_frames_array.infer_ROIs, &inference_frames_array.num_infer_ROIs,
+                        &result->inference_frame);
+    }
+
+    if (base->post_proc) {
+        ((PostProcFunction)base->post_proc)(blobs, &inference_frames_array, base->param.model_postproc, model->name,
+                                            base);
+    }
+
+    pthread_mutex_lock(&impl->output_frames_mutex);
+
+    for (int i = 0; i < inference_frames_array.num_infer_ROIs; i++) {
+        OutputFrame *output;
+        ff_list_t *out = impl->output_frames;
+        InferenceROI *frame = inference_frames_array.infer_ROIs[i];
+        iterator it = out->iterator_get(out);
+        while (it) {
+            output = (OutputFrame *)out->iterate_value(it);
+            if (frame->frame == output->frame || frame->frame == output->writable_frame) {
+                output->inference_count--;
+                break;
+            }
+            it = out->iterate_next(out, it);
+        }
+    }
+
+    PushOutput(impl);
+
+    for (int i = 0; i < user_data->num_buffers; i++)
+        av_free(user_data->frames[i]);
+
+    pthread_mutex_unlock(&impl->output_frames_mutex);
+
+    av_free(inference_frames_array.infer_ROIs);
+}
+
+static Model *CreateModel(FFBaseInference *base, const char *model_file, const char *model_proc_path,
+                          const char *object_class) {
+    int ret = 0;
+    Model *model = NULL;
+    const ImageInference *inference = image_inference_get_by_name("openvino");
+    const OutputBlobMethod *method = output_blob_method_get_by_name("openvino");
+    ImageInferenceContext *context = NULL;
+
+    av_log(NULL, AV_LOG_INFO, "Loading model: device=%s, path=%s\n", base->param.device, model_file);
+    av_log(NULL, AV_LOG_INFO, "Setting batch_size=%d, nireq=%d\n", base->param.batch_size, base->param.nireq);
+
+    context = image_inference_alloc(inference, method, "ffmpeg-image-infer");
+    model = (Model *)av_mallocz(sizeof(*model));
+    av_assert0(context && model);
+
+    ret = context->inference->Create(context, MEM_TYPE_ANY, base->param.device, model_file, base->param.batch_size,
+                                     base->param.nireq, base->param.infer_config, NULL, InferenceCompletionCallback);
+    av_assert0(ret == 0);
+
+    model->infer_ctx = context;
+    model->name = context->inference->GetModelName(context);
+    model->object_class = object_class ? av_strdup(object_class) : NULL;
+    model->input_preproc = NULL;
+
+    return model;
+}
+
+static void ReleaseModel(Model *model) {
+    ImageInferenceContext *ii_ctx;
+    if (!model)
+        return;
+
+    ii_ctx = model->infer_ctx;
+    ii_ctx->inference->Close(ii_ctx);
+    image_inference_free(ii_ctx);
+
+    if (model->object_class)
+        av_free(model->object_class);
+    av_free(model);
+}
+
+static void SubmitImage(Model *model, FFVideoRegionOfInterestMeta *meta, Image *image, AVFrame *frame) {
+    ImageInferenceContext *s = model->infer_ctx;
+    PreProcessor preProcessFunction = NULL;
+
+    InferenceResult *result = (InferenceResult *)malloc(sizeof(*result));
+    av_assert0(result);
+    result->inference_frame.frame = frame;
+    result->inference_frame.roi = *meta;
+    result->model = model;
+
+    image->rect = (Rectangle){.x = (int)meta->x, .y = (int)meta->y, .width = (int)meta->w, .height = (int)meta->h};
+#if 0
+    if (ff_base_inference->pre_proc && model.input_preproc) {
+        preProcessFunction = [&](InferenceBackend::Image &image) {
+            ((PreProcFunction)ff_base_inference->pre_proc)(model.input_preproc, image);
+        };
+    }
+    if (ff_base_inference->get_roi_pre_proc && model.input_preproc) {
+        preProcessFunction = ((GetROIPreProcFunction)ff_base_inference->get_roi_pre_proc)(model.input_preproc, meta);
+    }
+#endif
+    s->inference->SubmitImage(s, image, (IFramePtr)result, preProcessFunction);
+}
+
+static int SubmitImages(FFInferenceImpl *impl, const ROIMetaArray *metas, AVFrame *frame) {
+    int ret = 0;
+    Image image = {};
+
+    // TODO: map frame w/ different memory type to image
+    // BufferMapContext mapContext;
+
+    ff_buffer_map(frame, &image, MEM_TYPE_SYSTEM);
+
+    for (int i = 0; i < metas->num_metas; i++) {
+        // if (CheckObjectClass(model.object_class, meta->roi_type)) {
+        SubmitImage(impl->model, metas->roi_metas[i], &image, frame);
+        //}
+    }
+
+    // ff_buffer_unmap(buffer, image, mapContext);
+
+    return ret;
+}
+
+FFInferenceImpl *FFInferenceImplCreate(FFBaseInference *ff_base_inference) {
+    Model *dnn_model = NULL;
+    FFInferenceImpl *impl = (FFInferenceImpl *)av_mallocz(sizeof(*impl));
+
+    av_assert0(impl && ff_base_inference && ff_base_inference->param.model);
+
+    dnn_model = CreateModel(ff_base_inference, ff_base_inference->param.model, ff_base_inference->param.model_proc,
+                            ff_base_inference->param.object_class);
+    dnn_model->infer_impl = impl;
+
+    impl->model = dnn_model;
+    impl->base_inference = ff_base_inference;
+    impl->output_frames = ff_list_alloc();
+    impl->processed_frames = ff_list_alloc();
+
+    av_assert0(impl->output_frames && impl->processed_frames);
+
+    pthread_mutex_init(&impl->_mutex, NULL);
+    pthread_mutex_init(&impl->output_frames_mutex, NULL);
+
+    return impl;
+}
+
+void FFInferenceImplRelease(FFInferenceImpl *impl) {
+    if (!impl)
+        return;
+
+    ReleaseModel(impl->model);
+
+    ff_list_free(impl->output_frames);
+    ff_list_free(impl->processed_frames);
+
+    pthread_mutex_destroy(&impl->_mutex);
+    pthread_mutex_destroy(&impl->output_frames_mutex);
+
+    av_free(impl);
+}
+
+int FFInferenceImplAddFrame(void *ctx, FFInferenceImpl *impl, AVFrame *frame) {
+    const FFBaseInference *base_inference = impl->base_inference;
+    ROIMetaArray metas = {};
+    FFVideoRegionOfInterestMeta full_frame_meta = {};
+    // count number ROIs to run inference on
+    int inference_count = 0;
+    int run_inference = 0;
+
+    // Collect all ROI metas into std::vector
+    if (base_inference->param.is_full_frame) {
+        full_frame_meta.x = 0;
+        full_frame_meta.y = 0;
+        full_frame_meta.w = frame->width;
+        full_frame_meta.h = frame->height;
+        av_dynarray_add(&metas.roi_metas, &metas.num_metas, &full_frame_meta);
+    } else {
+        BBoxesArray *bboxes = NULL;
+        InferDetectionMeta *detect_meta = NULL;
+        AVFrameSideData *side_data = av_frame_get_side_data(frame, AV_FRAME_DATA_INFERENCE_DETECTION);
+        if (!side_data) {
+            // No ROI
+            impl->frame_num++;
+            goto output;
+        }
+
+        detect_meta = (InferDetectionMeta *)(side_data->data);
+        av_assert0(detect_meta);
+        bboxes = detect_meta->bboxes;
+        if (bboxes) {
+            for (int i = 0; i < bboxes->num; i++) {
+                FFVideoRegionOfInterestMeta *roi_meta = (FFVideoRegionOfInterestMeta *)av_malloc(sizeof(*roi_meta));
+                roi_meta->x = bboxes->bbox[i]->x_min;
+                roi_meta->y = bboxes->bbox[i]->y_min;
+                roi_meta->w = bboxes->bbox[i]->x_max - bboxes->bbox[i]->x_min;
+                roi_meta->h = bboxes->bbox[i]->y_max - bboxes->bbox[i]->y_min;
+                av_dynarray_add(&metas.roi_metas, &metas.num_metas, roi_meta);
+            }
+        }
+    }
+
+    impl->frame_num++;
+
+    for (int i = 0; i < metas.num_metas; i++) {
+        FFVideoRegionOfInterestMeta *meta = metas.roi_metas[i];
+        if (CheckObjectClass(impl->model->object_class, meta->type_name)) {
+            inference_count++;
+        }
+    }
+
+    run_inference =
+        !(inference_count == 0 ||
+          // ff_base_inference->every_nth_frame == -1 || // TODO separate property instead of -1
+          (base_inference->param.every_nth_frame > 0 && impl->frame_num % base_inference->param.every_nth_frame > 0));
+
+output:
+    // push into output_frames queue
+    {
+        OutputFrame *output_frame = (OutputFrame *)av_malloc(sizeof(*output_frame));
+        pthread_mutex_lock(&impl->output_frames_mutex);
+
+        output_frame->frame = frame;
+        output_frame->writable_frame = NULL; // TODO: alloc new frame if not writable
+        output_frame->inference_count = run_inference ? inference_count : 0;
+        impl->output_frames->push_back(impl->output_frames, output_frame);
+
+        if (!run_inference) {
+            // If we don't need to run inference and there are no frames queued for inference then finish transform
+            pthread_mutex_unlock(&impl->output_frames_mutex);
+            goto exit;
+        }
+
+        pthread_mutex_unlock(&impl->output_frames_mutex);
+    }
+
+    SubmitImages(impl, &metas, frame);
+
+exit:
+    if (!base_inference->param.is_full_frame) {
+        for (int n = 0; n < metas.num_metas; n++)
+            av_free(metas.roi_metas[n]);
+    }
+    av_free(metas.roi_metas);
+    return 0;
+}
+
+int FFInferenceImplGetFrame(void *ctx, FFInferenceImpl *impl, AVFrame **frame) {
+    ff_list_t *l = impl->processed_frames;
+
+    if (l->empty(l) || !frame)
+        return AVERROR(EAGAIN);
+
+    *frame = (AVFrame *)l->front(l);
+
+    l->pop_front(l);
+
+    return 0;
+}
+
+size_t FFInferenceImplGetQueueSize(void *ctx, FFInferenceImpl *impl) {
+    ff_list_t *out = impl->output_frames;
+    ff_list_t *pro = impl->processed_frames;
+    av_log(ctx, AV_LOG_INFO, "output:%zu processed:%zu\n", out->size(out), pro->size(pro));
+    return out->size(out) + pro->size(pro);
+}
+
+void FFInferenceImplSinkEvent(void *ctx, FFInferenceImpl *impl, FF_INFERENCE_EVENT event) {
+    if (event == INFERENCE_EVENT_EOS) {
+        impl->model->infer_ctx->inference->Flush(impl->model->infer_ctx);
+    }
+}
\ No newline at end of file
diff --git a/libavfilter/inference_backend/ff_inference_impl.h b/libavfilter/inference_backend/ff_inference_impl.h
new file mode 100644
index 0000000..04729fb
--- /dev/null
+++ b/libavfilter/inference_backend/ff_inference_impl.h
@@ -0,0 +1,21 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#include "ff_base_inference.h"
+
+typedef struct __FFInferenceImpl FFInferenceImpl;
+
+FFInferenceImpl *FFInferenceImplCreate(FFBaseInference *ff_base_inference);
+
+void FFInferenceImplRelease(FFInferenceImpl *impl);
+
+int FFInferenceImplAddFrame(void *ctx, FFInferenceImpl *impl, AVFrame *frame);
+
+int FFInferenceImplGetFrame(void *ctx, FFInferenceImpl *impl, AVFrame **frame);
+
+size_t FFInferenceImplGetQueueSize(void *ctx, FFInferenceImpl *impl);
+
+void FFInferenceImplSinkEvent(void *ctx, FFInferenceImpl *impl, FF_INFERENCE_EVENT event);
\ No newline at end of file
diff --git a/libavfilter/inference_backend/ff_list.c b/libavfilter/inference_backend/ff_list.c
new file mode 100644
index 0000000..a38e845
--- /dev/null
+++ b/libavfilter/inference_backend/ff_list.c
@@ -0,0 +1,79 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#include "ff_list.h"
+#include "queue.c"
+
+static void *_ff_list_pop_back(void *thiz) {
+    return queue_pop_back((queue_t *)((ff_list_t *)thiz)->opaque);
+}
+
+static void *_ff_list_pop_front(void *thiz) {
+    return queue_pop_front((queue_t *)((ff_list_t *)thiz)->opaque);
+}
+
+static void _ff_list_push_back(void *thiz, void *item) {
+    queue_push_back((queue_t *)((ff_list_t *)thiz)->opaque, item);
+}
+
+static void _ff_list_push_front(void *thiz, void *item) {
+    queue_push_front((queue_t *)((ff_list_t *)thiz)->opaque, item);
+}
+
+static void *_ff_list_front(void *thiz) {
+    return queue_peek_front((queue_t *)((ff_list_t *)thiz)->opaque);
+}
+
+static int _ff_list_empty(void *thiz) {
+    return queue_count((queue_t *)((ff_list_t *)thiz)->opaque) == 0;
+}
+
+static iterator _ff_list_iterator_get(void *thiz) {
+    return queue_iterate((queue_t *)((ff_list_t *)thiz)->opaque);
+}
+
+static iterator _ff_list_iterate_next(void *thiz, iterator it) {
+    return queue_iterate_next((queue_t *)((ff_list_t *)thiz)->opaque, (queue_entry_t *)it);
+}
+
+static void *_ff_list_iterate_value(iterator it) {
+    return queue_iterate_value((queue_entry_t *)it);
+}
+
+static size_t _ff_list_size(void *thiz) {
+    return queue_count((queue_t *)((ff_list_t *)thiz)->opaque);
+}
+
+ff_list_t *ff_list_alloc(void) {
+    ff_list_t *thiz = (ff_list_t *)malloc(sizeof(*thiz));
+    if (!thiz)
+        return NULL;
+
+    queue_t *q = queue_create();
+    assert(q);
+
+    thiz->opaque = q;
+    thiz->size = _ff_list_size;
+    thiz->empty = _ff_list_empty;
+    thiz->front = _ff_list_front;
+    thiz->pop_back = _ff_list_pop_back;
+    thiz->pop_front = _ff_list_pop_front;
+    thiz->push_back = _ff_list_push_back;
+    thiz->push_front = _ff_list_push_front;
+    thiz->iterator_get = _ff_list_iterator_get;
+    thiz->iterate_next = _ff_list_iterate_next;
+    thiz->iterate_value = _ff_list_iterate_value;
+
+    return thiz;
+}
+
+void ff_list_free(ff_list_t *thiz) {
+    if (!thiz)
+        return;
+
+    queue_destroy((queue_t *)thiz->opaque);
+    free(thiz);
+}
\ No newline at end of file
diff --git a/libavfilter/inference_backend/ff_list.h b/libavfilter/inference_backend/ff_list.h
new file mode 100644
index 0000000..61c1b80
--- /dev/null
+++ b/libavfilter/inference_backend/ff_list.h
@@ -0,0 +1,41 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#ifndef __FF_LIST_H
+#define __FF_LIST_H
+
+typedef void *iterator;
+
+typedef struct __ff_list {
+    const void *opaque; // private data
+
+    void *(*pop_back)(void *thiz);
+
+    void *(*pop_front)(void *thiz);
+
+    void (*push_back)(void *thiz, void *item);
+
+    void (*push_front)(void *thiz, void *item);
+
+    void *(*front)(void *thiz);
+
+    void *(*next)(void *thiz, void *current);
+
+    int (*empty)(void *thiz);
+
+    unsigned long (*size)(void *thiz);
+
+    iterator (*iterator_get)(void *thiz);
+
+    iterator (*iterate_next)(void *thiz, iterator it);
+
+    void *(*iterate_value)(iterator it);
+} ff_list_t;
+
+ff_list_t *ff_list_alloc(void);
+void ff_list_free(ff_list_t *thiz);
+
+#endif // __FF_LIST_H
diff --git a/libavfilter/inference_backend/ff_pre_proc.c b/libavfilter/inference_backend/ff_pre_proc.c
new file mode 100644
index 0000000..fb3f95f
--- /dev/null
+++ b/libavfilter/inference_backend/ff_pre_proc.c
@@ -0,0 +1,119 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#include "pre_proc.h"
+#include <assert.h>
+#include <libswscale/swscale.h>
+
+#if CONFIG_SWSCALE || HAVE_FFMPEG
+
+#ifdef DEBUG
+static void DumpBGRpToFile(const Image *out_image) {
+    FILE *fp;
+    char file_name[256] = {};
+    static int dump_frame_num = 0;
+
+    sprintf(file_name, "ff_pre_proc%03d.rgb", dump_frame_num++);
+    fp = fopen(file_name, "w+b");
+    assert(fp);
+
+    const uint8_t *b_channel = out_image->planes[0];
+    const uint8_t *g_channel = out_image->planes[1];
+    const uint8_t *r_channel = out_image->planes[2];
+
+    int size = out_image->height * out_image->width * 3;
+    uint8_t *data = (uint8_t *)malloc(size);
+    memset(data, 0, size);
+
+    for (int i = 0; i < out_image->height; i++) {
+        for (int j = 0; j < out_image->width; j++) {
+            data[3 * j + i * 3 * out_image->width] = r_channel[j + i * out_image->width];
+            data[3 * j + i * 3 * out_image->width + 1] = g_channel[j + i * out_image->width];
+            data[3 * j + i * 3 * out_image->width + 2] = b_channel[j + i * out_image->width];
+        }
+    }
+    fwrite(data, out_image->height * out_image->width * 3, 1, fp);
+    free(data);
+    fclose(fp);
+}
+#endif
+
+static inline enum AVPixelFormat FOURCC2FFmpegFormat(int format) {
+    switch (format) {
+    case FOURCC_NV12:
+        return AV_PIX_FMT_NV12;
+    case FOURCC_BGRA:
+        return AV_PIX_FMT_BGRA;
+    case FOURCC_BGRX:
+        return AV_PIX_FMT_BGRA;
+    case FOURCC_BGR:
+        return AV_PIX_FMT_BGR24;
+    case FOURCC_I420:
+        return AV_PIX_FMT_YUV420P;
+    }
+    return AV_PIX_FMT_NONE;
+}
+
+typedef struct FFPreProc {
+    struct SwsContext *sws_context;
+} FFPreProc;
+
+static void FFPreProcConvert(PreProcContext *context, const Image *src, Image *dst, int bAllocateDestination) {
+    FFPreProc *ff_pre_proc = (FFPreProc *)context->priv;
+    struct SwsContext *sws_context = ff_pre_proc->sws_context;
+    uint8_t *gbr_planes[3] = {};
+
+    // if identical format and resolution
+    if (src->format == dst->format && src->format == FOURCC_RGBP && src->width == dst->width &&
+        src->height == dst->height) {
+        int planes_count = GetPlanesCount(src->format);
+        for (int i = 0; i < planes_count; i++) {
+            if (src->width == src->stride[i]) {
+                memcpy(dst->planes[i], src->planes[i], src->width * src->height * sizeof(uint8_t));
+            } else {
+                int dst_stride = src->width * sizeof(uint8_t);
+                int src_stride = src->stride[i] * sizeof(uint8_t);
+                for (int r = 0; r < src->height; r++) {
+                    memcpy(dst->planes[i] + r * dst_stride, src->planes[i] + r * src_stride, dst_stride);
+                }
+            }
+        }
+    }
+
+    sws_context = sws_getCachedContext(sws_context, src->width, src->height, FOURCC2FFmpegFormat(src->format),
+                                       dst->width, dst->height, AV_PIX_FMT_GBRP, SWS_BILINEAR, NULL, NULL, NULL);
+    assert(sws_context);
+    // BGR->GBR
+    gbr_planes[0] = dst->planes[1];
+    gbr_planes[1] = dst->planes[0];
+    gbr_planes[2] = dst->planes[2];
+    if (!sws_scale(sws_context, (const uint8_t *const *)src->planes, src->stride, 0, src->height, gbr_planes,
+                   dst->stride)) {
+        fprintf(stderr, "Error on FFMPEG sws_scale\n");
+        assert(0);
+    }
+    /* dump pre-processed image to file */
+    // DumpBGRpToFile(dst);
+    ff_pre_proc->sws_context = sws_context;
+}
+
+static void FFPreProcDestroy(PreProcContext *context) {
+    FFPreProc *ff_pre_proc = (FFPreProc *)context->priv;
+    if (ff_pre_proc->sws_context) {
+        sws_freeContext(ff_pre_proc->sws_context);
+        ff_pre_proc->sws_context = NULL;
+    }
+}
+
+PreProc pre_proc_ffmpeg = {
+    .name = "ffmpeg",
+    .priv_size = sizeof(FFPreProc),
+    .mem_type = MEM_TYPE_SYSTEM,
+    .Convert = FFPreProcConvert,
+    .Destroy = FFPreProcDestroy,
+};
+
+#endif
\ No newline at end of file
diff --git a/libavfilter/inference_backend/ff_proc_factory.c b/libavfilter/inference_backend/ff_proc_factory.c
new file mode 100644
index 0000000..f03d41f
--- /dev/null
+++ b/libavfilter/inference_backend/ff_proc_factory.c
@@ -0,0 +1,187 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#include "ff_proc_factory.h"
+#include <libavutil/avassert.h>
+
+static void infer_detect_metadata_buffer_free(void *opaque, uint8_t *data) {
+    BBoxesArray *bboxes = ((InferDetectionMeta *)data)->bboxes;
+
+    if (bboxes) {
+        int i;
+        for (i = 0; i < bboxes->num; i++) {
+            InferDetection *p = bboxes->bbox[i];
+            if (p->label_buf)
+                av_buffer_unref(&p->label_buf);
+            av_freep(&p);
+        }
+        av_free(bboxes->bbox);
+        av_freep(&bboxes);
+    }
+
+    av_free(data);
+}
+
+static void ExtractBoundingBoxes(const OutputBlobArray *blob_array, InferenceROIArray *infer_roi_array,
+                                 ModelOutputPostproc *model_postproc, const char *model_name,
+                                 const FFBaseInference *ff_base_inference) {
+    for (int n = 0; n < blob_array->num_blobs; n++) {
+        AVBufferRef *labels = NULL;
+        BBoxesArray **boxes = NULL;
+        OutputBlobContext *ctx = blob_array->output_blobs[n];
+        const OutputBlobMethod *blob = ctx->output_blob_method;
+
+        const char *layer_name = blob->GetOutputLayerName(ctx);
+        const float *detections = (const float *)blob->GetData(ctx);
+
+        Dimensions *dim = blob->GetDims(ctx);
+        IILayout layout = blob->GetLayout(ctx);
+
+        int object_size = 0;
+        int max_proposal_count = 0;
+        float threshold = ff_base_inference->param.threshold;
+
+        switch (layout) {
+        case II_LAYOUT_NCHW:
+            object_size = dim->dims[3];
+            max_proposal_count = dim->dims[2];
+            break;
+        default:
+            av_log(NULL, AV_LOG_ERROR, "Unsupported output layout, boxes won't be extracted\n");
+            continue;
+        }
+
+        if (object_size != 7) { // SSD DetectionOutput format
+            av_log(NULL, AV_LOG_ERROR, "Unsupported output dimensions, boxes won't be extracted\n");
+            continue;
+        }
+
+        if (ff_base_inference->param.model_postproc) {
+            int idx = findModelPostProcByName(ff_base_inference->param.model_postproc, layer_name);
+            if (idx != MAX_MODEL_OUTPUT)
+                labels = ff_base_inference->param.model_postproc->procs[idx].labels;
+        }
+
+        boxes = (BBoxesArray **)av_mallocz_array(infer_roi_array->num_infer_ROIs, sizeof(boxes[0]));
+        av_assert0(boxes);
+
+        for (int i = 0; i < max_proposal_count; i++) {
+            int image_id = (int)detections[i * object_size + 0];
+            int label_id = (int)detections[i * object_size + 1];
+            float confidence = detections[i * object_size + 2];
+            float x_min = detections[i * object_size + 3];
+            float y_min = detections[i * object_size + 4];
+            float x_max = detections[i * object_size + 5];
+            float y_max = detections[i * object_size + 6];
+            if (image_id < 0 || (size_t)image_id >= infer_roi_array->num_infer_ROIs)
+                break;
+
+            if (confidence < threshold)
+                continue;
+
+            if (boxes[image_id] == NULL) {
+                boxes[image_id] = (BBoxesArray *)av_mallocz(sizeof(*boxes[image_id]));
+                av_assert0(boxes[image_id]);
+            }
+
+            /* using integer to represent */
+            {
+                FFVideoRegionOfInterestMeta *roi = &infer_roi_array->infer_ROIs[image_id]->roi;
+                InferDetection *new_bbox = (InferDetection *)av_mallocz(sizeof(*new_bbox));
+
+                int width = roi->w;
+                int height = roi->h;
+                int ix_min = (int)(x_min * width + 0.5);
+                int iy_min = (int)(y_min * height + 0.5);
+                int ix_max = (int)(x_max * width + 0.5);
+                int iy_max = (int)(y_max * height + 0.5);
+
+                if (ix_min < 0)
+                    ix_min = 0;
+                if (iy_min < 0)
+                    iy_min = 0;
+                if (ix_max > width)
+                    ix_max = width;
+                if (iy_max > height)
+                    iy_max = height;
+
+                av_assert0(new_bbox);
+                new_bbox->x_min = ix_min;
+                new_bbox->y_min = iy_min;
+                new_bbox->x_max = ix_max;
+                new_bbox->y_max = iy_max;
+                new_bbox->confidence = confidence;
+                new_bbox->label_id = label_id;
+                if (labels)
+                    new_bbox->label_buf = av_buffer_ref(labels);
+                av_dynarray_add(&boxes[image_id]->bbox, &boxes[image_id]->num, new_bbox);
+            }
+        }
+
+        for (int n = 0; n < infer_roi_array->num_infer_ROIs; n++) {
+            AVBufferRef *ref;
+            AVFrame *av_frame;
+            AVFrameSideData *sd;
+
+            InferDetectionMeta *detect_meta = (InferDetectionMeta *)av_malloc(sizeof(*detect_meta));
+            av_assert0(detect_meta);
+
+            detect_meta->bboxes = boxes[n];
+
+            ref = av_buffer_create((uint8_t *)detect_meta, sizeof(*detect_meta), &infer_detect_metadata_buffer_free,
+                                   NULL, 0);
+            if (ref == NULL) {
+                infer_detect_metadata_buffer_free(NULL, (uint8_t *)detect_meta);
+                av_assert0(ref);
+            }
+
+            av_frame = infer_roi_array->infer_ROIs[n]->frame;
+            // add meta data to side data
+            sd = av_frame_new_side_data_from_buf(av_frame, AV_FRAME_DATA_INFERENCE_DETECTION, ref);
+            if (sd == NULL) {
+                av_buffer_unref(&ref);
+                av_assert0(sd);
+            }
+            av_log(NULL, AV_LOG_DEBUG, "av_frame:%p sd:%d\n", av_frame, av_frame->nb_side_data);
+        }
+
+        av_free(boxes);
+    }
+}
+
+static void ExtractYOLOV3BoundingBoxes(const OutputBlobArray *output_blobs, InferenceROIArray *infer_roi_array,
+                                       ModelOutputPostproc *model_postproc, const char *model_name,
+                                       const FFBaseInference *ff_base_inference) {
+}
+
+PostProcFunction getPostProcFunctionByName(const char *name, const char *model) {
+    if (name == NULL || model == NULL)
+        return NULL;
+
+    if (!strcmp(name, "ie_detect")) {
+        if (strstr(model, "yolo"))
+            return (PostProcFunction)ExtractYOLOV3BoundingBoxes;
+        else
+            return (PostProcFunction)ExtractBoundingBoxes;
+    }
+    return NULL;
+}
+
+int findModelPostProcByName(ModelOutputPostproc *model_postproc, const char *layer_name) {
+    int proc_id;
+    // search model postproc
+    for (proc_id = 0; proc_id < MAX_MODEL_OUTPUT; proc_id++) {
+        char *proc_layer_name = model_postproc->procs[proc_id].layer_name;
+        // skip this output process
+        if (!proc_layer_name)
+            continue;
+        if (!strcmp(layer_name, proc_layer_name))
+            return proc_id;
+    }
+
+    av_log(NULL, AV_LOG_DEBUG, "Could not find proc:%s\n", layer_name);
+    return proc_id;
+}
\ No newline at end of file
diff --git a/libavfilter/inference_backend/ff_proc_factory.h b/libavfilter/inference_backend/ff_proc_factory.h
new file mode 100644
index 0000000..1836f06
--- /dev/null
+++ b/libavfilter/inference_backend/ff_proc_factory.h
@@ -0,0 +1,13 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#pragma once
+
+#include "ff_base_inference.h"
+
+PostProcFunction getPostProcFunctionByName(const char *name, const char *model);
+
+int findModelPostProcByName(ModelOutputPostproc *model_postproc, const char *layer_name);
\ No newline at end of file
diff --git a/libavfilter/inference_backend/image.h b/libavfilter/inference_backend/image.h
new file mode 100644
index 0000000..bbdf9d3
--- /dev/null
+++ b/libavfilter/inference_backend/image.h
@@ -0,0 +1,46 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#pragma once
+
+#include <stdint.h>
+
+typedef enum MemoryType { MEM_TYPE_ANY = 0, MEM_TYPE_SYSTEM = 1, MEM_TYPE_OPENCL = 2, MEM_TYPE_VAAPI = 3 } MemoryType;
+
+typedef enum FourCC {
+    FOURCC_NV12 = 0x3231564E,
+    FOURCC_BGRA = 0x41524742,
+    FOURCC_BGRX = 0x58524742,
+    FOURCC_BGRP = 0x50524742,
+    FOURCC_BGR = 0x00524742,
+    FOURCC_RGBA = 0x41424752,
+    FOURCC_RGBX = 0x58424752,
+    FOURCC_RGBP = 0x50424752,
+    FOURCC_RGBP_F32 = 0x07282024,
+    FOURCC_I420 = 0x30323449,
+} FourCC;
+
+typedef struct Rectangle {
+    int x;
+    int y;
+    int width;
+    int height;
+} Rectangle;
+
+#define MAX_PLANES_NUMBER 4
+
+typedef struct Image {
+    MemoryType type;
+    union {
+        uint8_t *planes[MAX_PLANES_NUMBER]; // if type==SYSTEM
+        void *cl_mem;                       // if type==OPENCL
+    };
+    int format; // FourCC
+    int width;
+    int height;
+    int stride[MAX_PLANES_NUMBER];
+    Rectangle rect;
+} Image;
diff --git a/libavfilter/inference_backend/image_inference.c b/libavfilter/inference_backend/image_inference.c
new file mode 100644
index 0000000..f2ce9b6
--- /dev/null
+++ b/libavfilter/inference_backend/image_inference.c
@@ -0,0 +1,183 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#include "image_inference.h"
+#include <limits.h>
+#include <string.h>
+
+extern OutputBlobMethod output_blob_method_openvino;
+extern ImageInference image_inference_openvino;
+
+static const ImageInference *const image_inference_list[] = {&image_inference_openvino, NULL};
+static const OutputBlobMethod *const output_blob_method_list[] = {&output_blob_method_openvino, NULL};
+
+static const ImageInference *image_inference_iterate(void **opaque) {
+    uintptr_t i = (uintptr_t)*opaque;
+    const ImageInference *ii = image_inference_list[i];
+
+    if (ii != NULL)
+        *opaque = (void *)(i + 1);
+
+    return ii;
+}
+
+static const OutputBlobMethod *output_blob_iterate(void **opaque) {
+    uintptr_t i = (uintptr_t)*opaque;
+    const OutputBlobMethod *obm = output_blob_method_list[i];
+
+    if (obm != NULL)
+        *opaque = (void *)(i + 1);
+
+    return obm;
+}
+
+const ImageInference *image_inference_get_by_name(const char *name) {
+    const ImageInference *ii = NULL;
+    void *opaque = 0;
+
+    if (name == NULL)
+        return NULL;
+
+    while ((ii = image_inference_iterate(&opaque)))
+        if (!strcmp(ii->name, name))
+            return (ImageInference *)ii;
+
+    return NULL;
+}
+
+ImageInferenceContext *image_inference_alloc(const ImageInference *infernce, const OutputBlobMethod *obm,
+                                             const char *instance_name) {
+    ImageInferenceContext *ret;
+
+    if (infernce == NULL)
+        return NULL;
+
+    ret = (ImageInferenceContext *)malloc(sizeof(*ret));
+    if (!ret)
+        return NULL;
+    memset(ret, 0, sizeof(*ret));
+
+    ret->inference = infernce;
+    ret->output_blob_method = obm;
+    ret->name = instance_name ? strdup(instance_name) : NULL;
+    if (infernce->priv_size > 0) {
+        ret->priv = malloc(infernce->priv_size);
+        if (!ret->priv)
+            goto err;
+        memset(ret->priv, 0, infernce->priv_size);
+    }
+
+    return ret;
+err:
+    free(ret->priv);
+    free(ret);
+    return NULL;
+}
+
+void image_inference_free(ImageInferenceContext *inference_context) {
+    if (inference_context == NULL)
+        return;
+
+    if (inference_context->priv)
+        free(inference_context->priv);
+    if (inference_context->name)
+        free(inference_context->name);
+    free(inference_context);
+}
+
+const OutputBlobMethod *output_blob_method_get_by_name(const char *name) {
+    const OutputBlobMethod *ob = NULL;
+    void *opaque = 0;
+
+    if (name == NULL)
+        return NULL;
+
+    while ((ob = output_blob_iterate(&opaque)))
+        if (!strcmp(ob->name, name))
+            return (OutputBlobMethod *)ob;
+
+    return NULL;
+}
+
+OutputBlobContext *output_blob_alloc(const OutputBlobMethod *obm) {
+    OutputBlobContext *ret;
+
+    if (obm == NULL)
+        return NULL;
+
+    ret = (OutputBlobContext *)malloc(sizeof(*ret));
+    if (!ret)
+        return NULL;
+    memset(ret, 0, sizeof(*ret));
+
+    ret->output_blob_method = obm;
+    if (obm->priv_size > 0) {
+        ret->priv = malloc(obm->priv_size);
+        if (!ret->priv)
+            goto err;
+        memset(ret->priv, 0, obm->priv_size);
+    }
+
+    return ret;
+err:
+    free(ret->priv);
+    free(ret);
+    return NULL;
+}
+
+void output_blob_free(OutputBlobContext *context) {
+    if (context == NULL)
+        return;
+
+    if (context->priv)
+        free(context->priv);
+    free(context);
+}
+
+#define FF_DYNARRAY_ADD(av_size_max, av_elt_size, av_array, av_size, av_success, av_failure)                           \
+    do {                                                                                                               \
+        size_t av_size_new = (av_size);                                                                                \
+        if (!((av_size) & ((av_size)-1))) {                                                                            \
+            av_size_new = (av_size) ? (av_size) << 1 : 1;                                                              \
+            if (av_size_new > (av_size_max) / (av_elt_size)) {                                                         \
+                av_size_new = 0;                                                                                       \
+            } else {                                                                                                   \
+                void *av_array_new = realloc((av_array), av_size_new * (av_elt_size));                                 \
+                if (!av_array_new)                                                                                     \
+                    av_size_new = 0;                                                                                   \
+                else                                                                                                   \
+                    (av_array) = (void **)av_array_new;                                                                \
+            }                                                                                                          \
+        }                                                                                                              \
+        if (av_size_new) {                                                                                             \
+            {av_success}(av_size)++;                                                                                   \
+        } else {                                                                                                       \
+            av_failure                                                                                                 \
+        }                                                                                                              \
+    } while (0)
+
+static void ii_freep(void *arg) {
+    void *val;
+
+    memcpy(&val, arg, sizeof(val));
+    memcpy(arg, &(void *){NULL}, sizeof(val));
+    free(val);
+}
+
+void image_inference_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem) {
+    void **tab;
+    memcpy(&tab, tab_ptr, sizeof(tab));
+
+    FF_DYNARRAY_ADD(INT_MAX, sizeof(*tab), tab, *nb_ptr,
+                    {
+                        tab[*nb_ptr] = elem;
+                        memcpy(tab_ptr, &tab, sizeof(tab));
+                    },
+                    {
+                        *nb_ptr = 0;
+                        ii_freep(tab_ptr);
+                    });
+}
\ No newline at end of file
diff --git a/libavfilter/inference_backend/image_inference.h b/libavfilter/inference_backend/image_inference.h
new file mode 100644
index 0000000..628c54e
--- /dev/null
+++ b/libavfilter/inference_backend/image_inference.h
@@ -0,0 +1,137 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#pragma once
+
+#include "image.h"
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+typedef enum {
+    II_LAYOUT_ANY = 0,
+    II_LAYOUT_NCHW = 1,
+    II_LAYOUT_NHWC = 2,
+} IILayout;
+
+typedef enum {
+    II_FP32 = 10,
+    II_U8 = 40,
+} IIPrecision;
+
+/* Don't change this structure */
+#define II_MAX_DIMENSIONS 8
+typedef struct Dimensions {
+    size_t num_dims;
+    size_t dims[II_MAX_DIMENSIONS];
+} Dimensions;
+
+typedef void *IFramePtr;
+
+typedef struct UserDataBuffers {
+    IFramePtr *frames;
+    int num_buffers;
+} UserDataBuffers;
+
+typedef struct OutputBlobMethod OutputBlobMethod;
+typedef struct OutputBlobArray OutputBlobArray;
+typedef struct OutputBlobContext OutputBlobContext;
+typedef struct ImageInference ImageInference;
+typedef struct ImageInferenceContext ImageInferenceContext;
+
+/**
+ * \brief Callback function when a inference request completed.
+ * Image inference backend takes charge of memory management for @param Blobs and @param frames
+ * Caller is responsible to every IFramePtr after reinterpreted as customed data structure
+ */
+typedef void (*CallbackFunc)(OutputBlobArray *Blobs, UserDataBuffers *frames);
+typedef void (*PreProcessor)(Image *image);
+
+struct ImageInference {
+    /* image inference backend name. Must be non-NULL and unique among backends. */
+    const char *name;
+
+    /* create image inference engine */
+    int (*Create)(ImageInferenceContext *ctx, MemoryType type, const char *devices, const char *model, int batch_size,
+                  int nireq, const char *config, void *allocator, CallbackFunc callback);
+
+    /* submit image */
+    void (*SubmitImage)(ImageInferenceContext *ctx, const Image *image, IFramePtr user_data,
+                        PreProcessor pre_processor);
+
+    const char *(*GetModelName)(ImageInferenceContext *ctx);
+
+    int (*IsQueueFull)(ImageInferenceContext *ctx);
+
+    void (*Flush)(ImageInferenceContext *ctx);
+
+    void (*Close)(ImageInferenceContext *ctx);
+
+    int priv_size; ///< size of private data to allocate for the backend
+};
+
+struct ImageInferenceContext {
+    const ImageInference *inference;
+    const OutputBlobMethod *output_blob_method;
+    char *name;
+    void *priv;
+};
+
+struct OutputBlobMethod {
+    /* output blob method name. Must be non-NULL and unique among output blob methods. */
+    const char *name;
+
+    const char *(*GetOutputLayerName)(OutputBlobContext *ctx);
+
+    IILayout (*GetLayout)(OutputBlobContext *ctx);
+
+    IIPrecision (*GetPrecision)(OutputBlobContext *ctx);
+
+    Dimensions *(*GetDims)(OutputBlobContext *ctx);
+
+    const void *(*GetData)(OutputBlobContext *ctx);
+
+    int priv_size; ///< size of private data to allocate for the output blob
+};
+
+struct OutputBlobContext {
+    const OutputBlobMethod *output_blob_method;
+    void *priv;
+};
+
+struct OutputBlobArray {
+    OutputBlobContext **output_blobs;
+    int num_blobs;
+};
+
+#define __STRING(x) #x
+
+#ifdef __cplusplus
+#define __CONFIG_KEY(name) KEY_##name
+#define __DECLARE_CONFIG_KEY(name) static const char *__CONFIG_KEY(name) = __STRING(name)
+__DECLARE_CONFIG_KEY(CPU_EXTENSION);          // library with implementation of custom layers
+__DECLARE_CONFIG_KEY(CPU_THROUGHPUT_STREAMS); // number inference requests running in parallel
+__DECLARE_CONFIG_KEY(RESIZE_BY_INFERENCE);    // experimental, don't use
+#else
+#define KEY_CPU_EXTENSION __STRING(CPU_EXTENSION)                   // library with implementation of custom layers
+#define KEY_CPU_THROUGHPUT_STREAMS __STRING(CPU_THROUGHPUT_STREAMS) // number inference requests running in parallel
+#define KEY_RESIZE_BY_INFERENCE __STRING(RESIZE_BY_INFERENCE)       // experimental, don't use
+#endif
+
+const ImageInference *image_inference_get_by_name(const char *name);
+
+ImageInferenceContext *image_inference_alloc(const ImageInference *infernce, const OutputBlobMethod *blob,
+                                             const char *instance_name);
+
+void image_inference_free(ImageInferenceContext *inference_context);
+
+const OutputBlobMethod *output_blob_method_get_by_name(const char *name);
+
+OutputBlobContext *output_blob_alloc(const OutputBlobMethod *method);
+
+void output_blob_free(OutputBlobContext *context);
+
+void image_inference_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem);
\ No newline at end of file
diff --git a/libavfilter/inference_backend/logger.c b/libavfilter/inference_backend/logger.c
new file mode 100644
index 0000000..96c6600
--- /dev/null
+++ b/libavfilter/inference_backend/logger.c
@@ -0,0 +1,27 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#include "logger.h"
+#include <stdio.h>
+#include <string.h>
+
+static VAIILogFuncPtr inference_log_function = NULL;
+
+void set_log_function(VAIILogFuncPtr log_func) {
+    inference_log_function = log_func;
+};
+
+void debug_log(int level, const char *file, const char *function, int line, const char *message) {
+    if (!inference_log_function) {
+        set_log_function(default_log_function);
+    }
+    (*inference_log_function)(level, file, function, line, message);
+};
+
+void default_log_function(int level, const char *file, const char *function, int line, const char *message) {
+    const char log_level[][16] = {"DEFAULT", "ERROR", "WARNING", "FIXME", "INFO", "DEBUG", "LOG", "TRACE", "MEMDUMP"};
+    fprintf(stderr, "%s \t %s:%i : %s \t %s \n", (char *)&log_level[level], file, line, function, message);
+}
diff --git a/libavfilter/inference_backend/logger.h b/libavfilter/inference_backend/logger.h
new file mode 100644
index 0000000..616088d
--- /dev/null
+++ b/libavfilter/inference_backend/logger.h
@@ -0,0 +1,60 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#pragma once
+
+enum {
+    VAII_ERROR_LOG_LEVEL = 1,
+    VAII_WARNING_LOG_LEVEL,
+    VAII_FIXME_LOG_LEVEL,
+    VAII_INFO_LOG_LEVEL,
+    VAII_DEBUG_LEVEL,
+    VAII_LOG_LOG_LEVEL,
+    VAII_TRACE_LOG_LEVEL,
+    VAII_MEMDUMP_LOG_LEVEL,
+};
+
+#define VAII_DEBUG_LOG(level, message) debug_log(level, __FILE__, __FUNCTION__, __LINE__, message);
+
+#define VAII_MEMDUMP(message) VAII_DEBUG_LOG(VAII_MEMDUMP_LOG_LEVEL, message);
+#define VAII_TRACE(message) VAII_DEBUG_LOG(VAII_TRACE_LOG_LEVEL, message);
+#define VAII_LOG(message) VAII_DEBUG_LOG(VAII_LOG_LOG_LEVEL, message);
+#define VAII_DEBUG(message) VAII_DEBUG_LOG(VAII_DEBUG_LEVEL, message);
+#define VAII_INFO(message) VAII_DEBUG_LOG(VAII_INFO_LOG_LEVEL, message);
+#define VAII_FIXME(message) VAII_DEBUG_LOG(VAII_FIXME_LOG_LEVEL, message);
+#define VAII_WARNING(message) VAII_DEBUG_LOG(VAII_WARNING_LOG_LEVEL, message);
+#define VAII_ERROR(message) VAII_DEBUG_LOG(VAII_ERROR_LOG_LEVEL, message);
+
+typedef void (*VAIILogFuncPtr)(int level, const char *file, const char *function, int line, const char *message);
+
+void set_log_function(VAIILogFuncPtr log_func);
+
+void debug_log(int level, const char *file, const char *function, int line, const char *message);
+
+void default_log_function(int level, const char *file, const char *function, int line, const char *message);
+
+#if defined(HAVE_ITT)
+#include "ittnotify.h"
+#include <string>
+
+static __itt_domain *itt_domain = NULL;
+inline void taskBegin(const char *name) {
+    if (itt_domain == NULL) {
+        itt_domain = __itt_domain_create("video-analytics");
+    }
+    __itt_task_begin(itt_domain, __itt_null, __itt_null, __itt_string_handle_create(name));
+}
+
+inline void taskEnd(void) {
+    __itt_task_end(itt_domain);
+}
+
+#else
+
+#define taskBegin(x)
+#define taskEnd(x)
+
+#endif
diff --git a/libavfilter/inference_backend/openvino_image_inference.c b/libavfilter/inference_backend/openvino_image_inference.c
new file mode 100644
index 0000000..1d7c384
--- /dev/null
+++ b/libavfilter/inference_backend/openvino_image_inference.c
@@ -0,0 +1,535 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#include <assert.h>
+#include <string.h>
+
+#include "image_inference.h"
+#include "logger.h"
+#include "openvino_image_inference.h"
+
+#define II_MAX(a, b) ((a) > (b) ? (a) : (b))
+#define II_MIN(a, b) ((a) > (b) ? (b) : (a))
+
+static void *WorkingFunction(void *arg);
+
+static inline int getNumberChannels(int format) {
+    switch (format) {
+    case FOURCC_BGRA:
+    case FOURCC_BGRX:
+    case FOURCC_RGBA:
+    case FOURCC_RGBX:
+        return 4;
+    case FOURCC_BGR:
+        return 3;
+    }
+    return 0;
+}
+
+static void GetNextImageBuffer(ImageInferenceContext *ctx, const BatchRequest *request, Image *image) {
+    OpenVINOImageInference *vino = (OpenVINOImageInference *)ctx->priv;
+    const char *input_name;
+    dimensions_t blob_dims = {};
+    int batchIndex, plane_size;
+
+    VAII_DEBUG(__FUNCTION__);
+    assert(vino->num_inputs != 0);
+
+    input_name = vino->inputs[0]->name; // assuming one input layer
+    infer_request_get_blob_dims(request->infer_request, input_name, &blob_dims);
+
+    memset(image, 0, sizeof(*image));
+    image->width = blob_dims.dims[2];
+    image->height = blob_dims.dims[3];
+    image->format = FOURCC_RGBP;
+    batchIndex = request->buffers.num_buffers;
+    plane_size = image->width * image->height;
+    image->planes[0] = (uint8_t *)infer_request_get_blob_data(request->infer_request, input_name) +
+                       batchIndex * plane_size * blob_dims.dims[2];
+    image->planes[1] = image->planes[0] + plane_size;
+    image->planes[2] = image->planes[1] + plane_size;
+    image->stride[0] = image->width;
+    image->stride[1] = image->width;
+    image->stride[2] = image->width;
+}
+
+static inline Image ApplyCrop(const Image *src) {
+    int planes_count;
+    int rect_x, rect_y, rect_width, rect_height;
+    Image dst = *src;
+    dst.rect = (Rectangle){0};
+
+    VAII_DEBUG(__FUNCTION__);
+
+    planes_count = GetPlanesCount(src->format);
+    if (!src->rect.width && !src->rect.height) {
+        dst = *src;
+        for (int i = 0; i < planes_count; i++)
+            dst.planes[i] = src->planes[i];
+        return dst;
+    }
+
+    if (src->rect.x >= src->width || src->rect.y >= src->height || src->rect.x + src->rect.width <= 0 ||
+        src->rect.y + src->rect.height <= 0) {
+        fprintf(stderr, "ERROR: ApplyCrop: Requested rectangle is out of image boundaries\n");
+        assert(0);
+    }
+
+    rect_x = II_MAX(src->rect.x, 0);
+    rect_y = II_MAX(src->rect.y, 0);
+    rect_width = II_MIN(src->rect.width - (rect_x - src->rect.x), src->width - rect_x);
+    rect_height = II_MIN(src->rect.height - (rect_y - src->rect.y), src->height - rect_y);
+
+    switch (src->format) {
+    case FOURCC_NV12: {
+        dst.planes[0] = src->planes[0] + rect_y * src->stride[0] + rect_x;
+        dst.planes[1] = src->planes[1] + (rect_y / 2) * src->stride[1] + rect_x;
+        break;
+    }
+    case FOURCC_I420: {
+        dst.planes[0] = src->planes[0] + rect_y * src->stride[0] + rect_x;
+        dst.planes[1] = src->planes[1] + (rect_y / 2) * src->stride[1] + (rect_x / 2);
+        dst.planes[2] = src->planes[2] + (rect_y / 2) * src->stride[2] + (rect_x / 2);
+        break;
+    }
+    case FOURCC_RGBP: {
+        dst.planes[0] = src->planes[0] + rect_y * src->stride[0] + rect_x;
+        dst.planes[1] = src->planes[1] + rect_y * src->stride[1] + rect_x;
+        dst.planes[2] = src->planes[2] + rect_y * src->stride[2] + rect_x;
+        break;
+    }
+    case FOURCC_BGR: {
+        int channels = 3;
+        dst.planes[0] = src->planes[0] + rect_y * src->stride[0] + rect_x * channels;
+        break;
+    }
+    default: {
+        int channels = 4;
+        dst.planes[0] = src->planes[0] + rect_y * src->stride[0] + rect_x * channels;
+        break;
+    }
+    }
+
+    if (rect_width)
+        dst.width = rect_width;
+    if (rect_height)
+        dst.height = rect_height;
+
+    return dst;
+}
+
+static void SubmitImageSoftwarePreProcess(ImageInferenceContext *ctx, const BatchRequest *request, const Image *pSrc,
+                                          PreProcessor preProcessor) {
+    OpenVINOImageInference *vino = (OpenVINOImageInference *)ctx->priv;
+
+    if (vino->resize_by_inference) {
+        // TODO: image to Blob
+    } else {
+        Image src = {};
+        Image dst = {};
+        GetNextImageBuffer(ctx, request, &dst);
+
+        if (pSrc->planes[0] != dst.planes[0]) { // only convert if different buffers
+            if (!vino->vpp_ctx) {
+                vino->vpp_ctx = pre_proc_alloc(pre_proc_get_by_type(MEM_TYPE_SYSTEM));
+                assert(vino->vpp_ctx);
+            }
+#ifdef HAVE_GAPI
+            vino->vpp_ctx->pre_proc->Convert(vino->vpp_ctx, &src, &dst, 0);
+#else
+            src = ApplyCrop(pSrc);
+            vino->vpp_ctx->pre_proc->Convert(vino->vpp_ctx, &src, &dst, 0);
+#endif
+            // model specific pre-processing
+            if (preProcessor)
+                preProcessor(&dst);
+        }
+    }
+}
+
+static int OpenVINOImageInferenceCreate(ImageInferenceContext *ctx, MemoryType type, const char *devices,
+                                        const char *model, int batch_size, int nireq, const char *configs,
+                                        void *allocator, CallbackFunc callback) {
+    OpenVINOImageInference *vino = (OpenVINOImageInference *)ctx->priv;
+    VAII_DEBUG("Create");
+
+    if (!model || !devices) {
+        VAII_ERROR("No model or device!");
+        return -1;
+    }
+
+    vino->plugin = ie_plugin_create(devices);
+    if (!vino->plugin) {
+        VAII_ERROR("Create plugin failed!");
+        return -1;
+    }
+
+    if (configs) {
+        const char *resize_by_vino = NULL;
+        ie_plugin_set_config(vino->plugin, configs);
+        // printf("KEY_CPU_THROUGHPUT_STREAMS:%s\n", ie_plugin_get_config(vino->plugin, KEY_CPU_THROUGHPUT_STREAMS));
+        resize_by_vino = ie_plugin_get_config(vino->plugin, KEY_RESIZE_BY_INFERENCE);
+        vino->resize_by_inference = (resize_by_vino && !strcmp(resize_by_vino, "TRUE")) ? 1 : 0;
+    }
+
+    // Extension for custom layers
+    if (strstr(devices, "CPU")) {
+        const char *cpu_ext = ie_plugin_get_config(vino->plugin, KEY_CPU_EXTENSION);
+        ie_plugin_add_cpu_extension(vino->plugin, cpu_ext);
+    }
+
+    // Load network
+    vino->network = ie_network_create(vino->plugin, model, NULL);
+    if (!vino->network) {
+        VAII_ERROR("Create network failed!");
+        goto err;
+    }
+
+    ie_network_set_batch(vino->network, batch_size);
+
+    // Check model input
+    vino->num_inputs = ie_network_get_input_number(vino->network);
+    vino->num_outputs = ie_network_get_output_number(vino->network);
+    if (vino->num_inputs == 0) {
+        VAII_ERROR("Input layer not found!");
+        goto err;
+    }
+
+    vino->inputs = (ie_input_info_t **)malloc(vino->num_inputs * sizeof(*vino->inputs));
+    vino->outputs = (ie_output_info_t **)malloc(vino->num_outputs * sizeof(*vino->outputs));
+    if (!vino->inputs || !vino->outputs) {
+        VAII_ERROR("Alloc in/outputs ptr failed!");
+        goto err;
+    }
+
+    for (size_t i = 0; i < vino->num_inputs; i++) {
+        vino->inputs[i] = (ie_input_info_t *)malloc(sizeof(*vino->inputs[i]));
+        if (!vino->inputs[i])
+            goto err;
+        memset(vino->inputs[i], 0, sizeof(*vino->inputs[i]));
+    }
+    for (size_t i = 0; i < vino->num_outputs; i++) {
+        vino->outputs[i] = (ie_output_info_t *)malloc(sizeof(*vino->outputs[i]));
+        if (!vino->outputs[i])
+            goto err;
+        memset(vino->outputs[i], 0, sizeof(*vino->outputs[i]));
+    }
+
+    ie_network_get_all_inputs(vino->network, vino->inputs);
+    ie_network_get_all_outputs(vino->network, vino->outputs);
+
+    ie_input_info_set_precision(vino->inputs[0], "U8");
+    if (vino->resize_by_inference) {
+        // TODO: set openvino preprocess algorithm
+        ie_input_info_set_layout(vino->inputs[0], "NHWC");
+    } else {
+        ie_input_info_set_layout(vino->inputs[0], "NCHW");
+    }
+
+    // Create infer requests
+    if (nireq == 0) {
+        VAII_ERROR("Input layer not found!");
+        goto err;
+    }
+
+    vino->infer_requests = ie_network_create_infer_requests(vino->network, nireq);
+    if (!vino->infer_requests) {
+        VAII_ERROR("Creat infer requests failed!");
+        goto err;
+    }
+
+    vino->batch_requests = (BatchRequest **)malloc(nireq * sizeof(*vino->batch_requests));
+    if (!vino->batch_requests) {
+        VAII_ERROR("Creat batch requests failed!");
+        goto err;
+    }
+    vino->num_batch_requests = nireq;
+
+    vino->freeRequests = SafeQueueCreate();
+    vino->workingRequests = SafeQueueCreate();
+    if (!vino->freeRequests || !vino->workingRequests) {
+        VAII_ERROR("Creat request queues failed!");
+        goto err;
+    }
+
+    for (size_t n = 0; n < vino->infer_requests->num_reqs; n++) {
+        BatchRequest *batch_request = (BatchRequest *)malloc(sizeof(*batch_request));
+        if (!batch_request)
+            goto err;
+        memset(batch_request, 0, sizeof(*batch_request));
+        batch_request->infer_request = vino->infer_requests->requests[n];
+        vino->batch_requests[n] = batch_request;
+        SafeQueuePush(vino->freeRequests, batch_request);
+    }
+
+    // TODO: handle allocator
+
+    vino->model_name = strdup(model);
+    if (!vino->model_name) {
+        VAII_ERROR("Copy model name failed!");
+        goto err;
+    }
+
+    pthread_mutex_init(&vino->flush_mutex, NULL);
+
+    vino->callback = callback;
+    pthread_create(&vino->working_thread, NULL, WorkingFunction, ctx);
+
+    return 0;
+err:
+    if (vino->inputs) {
+        for (size_t i = 0; i < vino->num_outputs; i++)
+            if (vino->inputs[i])
+                free(vino->inputs[i]);
+        free(vino->inputs);
+    }
+    if (vino->outputs) {
+        for (size_t i = 0; i < vino->num_outputs; i++)
+            if (vino->outputs[i])
+                free(vino->outputs[i]);
+        free(vino->outputs);
+    }
+    if (vino->batch_requests) {
+        for (size_t i = 0; i < vino->num_batch_requests; i++)
+            if (vino->batch_requests[i])
+                free(vino->batch_requests[i]);
+        free(vino->batch_requests);
+    }
+    if (vino->freeRequests)
+        SafeQueueDestroy(vino->freeRequests);
+    if (vino->workingRequests)
+        SafeQueueDestroy(vino->workingRequests);
+    ie_network_destroy(vino->network);
+    ie_plugin_destroy(vino->plugin);
+    return -1;
+}
+
+static void OpenVINOImageInferenceSubmtImage(ImageInferenceContext *ctx, const Image *image, IFramePtr user_data,
+                                             PreProcessor pre_processor) {
+    OpenVINOImageInference *vino = (OpenVINOImageInference *)ctx->priv;
+    const Image *pSrc = image;
+    BatchRequest *request = NULL;
+
+    VAII_DEBUG(__FUNCTION__);
+
+    // pop() call blocks if freeRequests is empty, i.e all requests still in workingRequests list and not completed
+    request = (BatchRequest *)SafeQueuePop(vino->freeRequests);
+
+    SubmitImageSoftwarePreProcess(ctx, request, pSrc, pre_processor);
+
+    image_inference_dynarray_add(&request->buffers.frames, &request->buffers.num_buffers, user_data);
+
+    // start inference asynchronously if enough buffers for batching
+    if (request->buffers.num_buffers >= vino->batch_size) {
+#if 1 // TODO: remove when license-plate-recognition-barrier model will take one input
+        if (vino->num_inputs > 1 && !strcmp(vino->inputs[1]->name, "seq_ind")) {
+            // 'seq_ind' input layer is some relic from the training
+            // it should have the leading 0.0f and rest 1.0f
+            dimensions_t dims = {};
+            float *blob_data;
+            int maxSequenceSizePerPlate;
+
+            infer_request_get_blob_dims(request->infer_request, vino->inputs[1]->name, &dims);
+            maxSequenceSizePerPlate = dims.dims[0];
+            blob_data = (float *)infer_request_get_blob_data(request->infer_request, vino->inputs[1]->name);
+            blob_data[0] = 0.0f;
+            for (int n = 1; n < maxSequenceSizePerPlate; n++)
+                blob_data[n] = 1.0f;
+        }
+#endif
+        infer_request_infer_async(request->infer_request);
+        SafeQueuePush(vino->workingRequests, request);
+    } else {
+        SafeQueuePushFront(vino->workingRequests, request);
+    }
+}
+
+static const char *OpenVINOImageInferenceGetModelName(ImageInferenceContext *ctx) {
+    OpenVINOImageInference *vino = (OpenVINOImageInference *)ctx->priv;
+    return vino->model_name;
+}
+
+static int OpenVINOImageInferenceIsQueueFull(ImageInferenceContext *ctx) {
+    OpenVINOImageInference *vino = (OpenVINOImageInference *)ctx->priv;
+    return SafeQueueEmpty(vino->freeRequests);
+}
+
+static void OpenVINOImageInferenceFlush(ImageInferenceContext *ctx) {
+    OpenVINOImageInference *vino = (OpenVINOImageInference *)ctx->priv;
+    BatchRequest *request = NULL;
+
+    pthread_mutex_lock(&vino->flush_mutex);
+
+    if (vino->already_flushed) {
+        pthread_mutex_unlock(&vino->flush_mutex);
+        return;
+    }
+
+    vino->already_flushed = 1;
+
+    request = (BatchRequest *)SafeQueuePop(vino->freeRequests);
+    if (request->buffers.num_buffers > 0) {
+        // push the last request to infer
+        infer_request_infer_async(request->infer_request);
+        SafeQueuePush(vino->workingRequests, request);
+    }
+    SafeQueueWaitEmpty(vino->workingRequests);
+
+    pthread_mutex_unlock(&vino->flush_mutex);
+}
+
+static void OpenVINOImageInferenceClose(ImageInferenceContext *ctx) {
+    OpenVINOImageInference *vino = (OpenVINOImageInference *)ctx->priv;
+
+    if (vino->working_thread) {
+        // add one empty request
+        BatchRequest batch_request = {};
+        SafeQueuePush(vino->workingRequests, &batch_request);
+        // wait for thread reaching empty request
+        pthread_join(vino->working_thread, NULL);
+    }
+
+    if (vino->inputs) {
+        for (size_t i = 0; i < vino->num_outputs; i++)
+            if (vino->inputs[i])
+                free(vino->inputs[i]);
+        free(vino->inputs);
+    }
+    if (vino->outputs) {
+        for (size_t i = 0; i < vino->num_outputs; i++)
+            if (vino->outputs[i])
+                free(vino->outputs[i]);
+        free(vino->outputs);
+    }
+    if (vino->batch_requests) {
+        for (size_t i = 0; i < vino->num_batch_requests; i++)
+            if (vino->batch_requests[i])
+                free(vino->batch_requests[i]);
+        free(vino->batch_requests);
+    }
+    if (vino->freeRequests)
+        SafeQueueDestroy(vino->freeRequests);
+    if (vino->workingRequests)
+        SafeQueueDestroy(vino->workingRequests);
+    ie_network_destroy(vino->network);
+    ie_plugin_destroy(vino->plugin);
+
+    if (vino->model_name)
+        free(vino->model_name);
+
+    pthread_mutex_destroy(&vino->flush_mutex);
+
+    if (vino->vpp_ctx) {
+        vino->vpp_ctx->pre_proc->Destroy(vino->vpp_ctx);
+        pre_proc_free(vino->vpp_ctx);
+    }
+}
+
+static void *WorkingFunction(void *arg) {
+    ImageInferenceContext *ctx = (ImageInferenceContext *)arg;
+    OpenVINOImageInference *vino = (OpenVINOImageInference *)ctx->priv;
+    VAII_DEBUG(__FUNCTION__);
+
+#define IE_REQUEST_WAIT_RESULT_READY -1
+    for (;;) {
+        IEStatusCode sts;
+        BatchRequest *request = (BatchRequest *)SafeQueueFront(vino->workingRequests);
+        VAII_DEBUG("loop");
+        if (!request->buffers.num_buffers) {
+            break;
+        }
+        sts = (IEStatusCode)infer_request_wait(request->infer_request, IE_REQUEST_WAIT_RESULT_READY);
+        if (IE_STATUS_OK == sts) {
+            OutputBlobArray blob_array = {};
+            ie_output_info_t **outputs = vino->outputs;
+
+            for (size_t i = 0; i < vino->num_outputs; i++) {
+                OpenVINOOutputBlob *vino_blob;
+                OutputBlobContext *blob_ctx = output_blob_alloc(ctx->output_blob_method);
+                assert(blob_ctx);
+                vino_blob = (OpenVINOOutputBlob *)blob_ctx->priv;
+                vino_blob->name = ie_info_get_name(outputs[i]);
+                vino_blob->blob = infer_request_get_blob(request->infer_request, vino_blob->name);
+                image_inference_dynarray_add(&blob_array.output_blobs, &blob_array.num_blobs, blob_ctx);
+            }
+
+            vino->callback(&blob_array, &request->buffers);
+
+            for (int n = 0; n < blob_array.num_blobs; n++) {
+                OutputBlobContext *blob_ctx = blob_array.output_blobs[n];
+                OpenVINOOutputBlob *vino_blob = (OpenVINOOutputBlob *)blob_ctx->priv;
+                infer_request_put_blob(vino_blob->blob);
+                output_blob_free(blob_ctx);
+                blob_array.num_blobs--;
+            }
+            assert(blob_array.num_blobs == 0);
+            free(blob_array.output_blobs);
+        } else {
+            fprintf(stderr, "Inference Error: %d", sts);
+            assert(0);
+        }
+
+        // move request from workingRequests to freeRequests list
+        request = (BatchRequest *)SafeQueuePop(vino->workingRequests);
+        // clear buffers
+        if (request->buffers.frames) {
+            free(request->buffers.frames);
+            request->buffers.frames = NULL;
+        }
+        request->buffers.num_buffers = 0;
+        SafeQueuePush(vino->freeRequests, request);
+    }
+
+    VAII_DEBUG("EXIT");
+
+    return NULL;
+}
+
+static const char *OpenVINOOutputBlobGetOutputLayerName(OutputBlobContext *ctx) {
+    OpenVINOOutputBlob *vino_blob = (OpenVINOOutputBlob *)ctx->priv;
+    return vino_blob->name;
+}
+
+static Dimensions *OpenVINOOutputBlobGetDims(OutputBlobContext *ctx) {
+    OpenVINOOutputBlob *vino_blob = (OpenVINOOutputBlob *)ctx->priv;
+    return (Dimensions *)ie_blob_get_dims(vino_blob->blob);
+}
+
+static IILayout OpenVINOOutputBlobGetLayout(OutputBlobContext *ctx) {
+    OpenVINOOutputBlob *vino_blob = (OpenVINOOutputBlob *)ctx->priv;
+    return (IILayout)ie_blob_get_layout(vino_blob->blob);
+}
+
+static IIPrecision OpenVINOOutputBlobGetPrecision(OutputBlobContext *ctx) {
+    OpenVINOOutputBlob *vino_blob = (OpenVINOOutputBlob *)ctx->priv;
+    return (IIPrecision)ie_blob_get_precision(vino_blob->blob);
+}
+
+static const void *OpenVINOOutputBlobGetData(OutputBlobContext *ctx) {
+    OpenVINOOutputBlob *vino_blob = (OpenVINOOutputBlob *)ctx->priv;
+    return ie_blob_get_data(vino_blob->blob);
+}
+
+OutputBlobMethod output_blob_method_openvino = {
+    .name = "openvino",
+    .priv_size = sizeof(OpenVINOOutputBlob),
+    .GetOutputLayerName = OpenVINOOutputBlobGetOutputLayerName,
+    .GetDims = OpenVINOOutputBlobGetDims,
+    .GetLayout = OpenVINOOutputBlobGetLayout,
+    .GetPrecision = OpenVINOOutputBlobGetPrecision,
+    .GetData = OpenVINOOutputBlobGetData,
+};
+
+ImageInference image_inference_openvino = {
+    .name = "openvino",
+    .priv_size = sizeof(OpenVINOImageInference),
+    .Create = OpenVINOImageInferenceCreate,
+    .SubmitImage = OpenVINOImageInferenceSubmtImage,
+    .GetModelName = OpenVINOImageInferenceGetModelName,
+    .IsQueueFull = OpenVINOImageInferenceIsQueueFull,
+    .Flush = OpenVINOImageInferenceFlush,
+    .Close = OpenVINOImageInferenceClose,
+};
diff --git a/libavfilter/inference_backend/openvino_image_inference.h b/libavfilter/inference_backend/openvino_image_inference.h
new file mode 100644
index 0000000..0b79994
--- /dev/null
+++ b/libavfilter/inference_backend/openvino_image_inference.h
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#pragma once
+
+#include <ie_c_api.h>
+#include "image_inference.h"
+#include "pre_proc.h"
+#include "safe_queue.h"
+#include <pthread.h>
+
+typedef struct BatchRequest {
+    infer_request_t *infer_request;
+    UserDataBuffers buffers;
+    // TODO: alloc_context
+} BatchRequest;
+
+typedef struct OpenVINOImageInference {
+    int resize_by_inference;
+
+    CallbackFunc callback;
+
+    // Inference Engine
+    ie_plugin_t *plugin;
+    ie_network_t *network;
+    ie_input_info_t **inputs;
+    ie_output_info_t **outputs;
+    size_t num_inputs;
+    size_t num_outputs;
+    char *model_name;
+    infer_requests_t *infer_requests;
+
+    BatchRequest **batch_requests;
+    size_t num_batch_requests;
+
+    // Threading
+    int batch_size;
+    pthread_t working_thread;
+    SafeQueueT *freeRequests;    // BatchRequest queue
+    SafeQueueT *workingRequests; // BatchRequest queue
+
+    // VPP
+    PreProcContext *vpp_ctx;
+
+    int already_flushed;
+    pthread_mutex_t flush_mutex;
+
+} OpenVINOImageInference;
+
+typedef struct OpenVINOOutputBlob {
+    const char *name;
+    ie_blob_t *blob;
+} OpenVINOOutputBlob;
diff --git a/libavfilter/inference_backend/pre_proc.c b/libavfilter/inference_backend/pre_proc.c
new file mode 100644
index 0000000..d0e7a8b
--- /dev/null
+++ b/libavfilter/inference_backend/pre_proc.c
@@ -0,0 +1,118 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#include "pre_proc.h"
+#include <stdlib.h>
+#include <string.h>
+
+extern PreProc pre_proc_ffmpeg;
+extern PreProc pre_proc_opencv;
+extern PreProc pre_proc_gapi;
+
+static const PreProc *const pre_proc_list[] = {
+#if HAVE_FFMPEG || CONFIG_SWSCALE
+    &pre_proc_ffmpeg,
+#endif
+#if HAVE_OPENCV
+    &pre_proc_opencv,
+#endif
+#if HAVE_GAPI
+    &pre_proc_gapi,
+#endif
+    NULL};
+
+int GetPlanesCount(int fourcc) {
+    switch (fourcc) {
+    case FOURCC_BGRA:
+    case FOURCC_BGRX:
+    case FOURCC_BGR:
+    case FOURCC_RGBA:
+    case FOURCC_RGBX:
+        return 1;
+    case FOURCC_NV12:
+        return 2;
+    case FOURCC_BGRP:
+    case FOURCC_RGBP:
+    case FOURCC_I420:
+        return 3;
+    }
+
+    return 0;
+}
+static const PreProc *pre_proc_iterate(void **opaque) {
+    uintptr_t i = (uintptr_t)*opaque;
+    const PreProc *pp = pre_proc_list[i];
+
+    if (pp != NULL)
+        *opaque = (void *)(i + 1);
+
+    return pp;
+}
+
+const PreProc *pre_proc_get_by_name(const char *name) {
+    const PreProc *pp = NULL;
+    void *opaque = 0;
+
+    if (name == NULL)
+        return NULL;
+
+    while ((pp = pre_proc_iterate(&opaque)))
+        if (!strcmp(pp->name, name))
+            return pp;
+
+    return NULL;
+}
+
+const PreProc *pre_proc_get_by_type(MemoryType type) {
+    const PreProc *ret = NULL;
+
+    if (type == MEM_TYPE_SYSTEM) {
+        ret = pre_proc_get_by_name("ffmpeg");
+        if (!ret)
+            ret = pre_proc_get_by_name("gapi");
+        if (!ret)
+            ret = pre_proc_get_by_name("opencv");
+    } else if (type == MEM_TYPE_VAAPI) {
+        ret = pre_proc_get_by_name("vaapi");
+    }
+
+    return ret;
+}
+
+PreProcContext *pre_proc_alloc(const PreProc *pre_proc) {
+    PreProcContext *ret;
+
+    if (pre_proc == NULL)
+        return NULL;
+
+    ret = (PreProcContext *)malloc(sizeof(*ret));
+    if (!ret)
+        return NULL;
+    memset(ret, 0, sizeof(*ret));
+
+    ret->pre_proc = pre_proc;
+    if (pre_proc->priv_size > 0) {
+        ret->priv = malloc(pre_proc->priv_size);
+        if (!ret->priv)
+            goto err;
+        memset(ret->priv, 0, pre_proc->priv_size);
+    }
+
+    return ret;
+err:
+    free(ret->priv);
+    free(ret);
+    return NULL;
+}
+
+void pre_proc_free(PreProcContext *context) {
+    if (context == NULL)
+        return;
+
+    if (context->priv)
+        free(context->priv);
+    free(context);
+}
diff --git a/libavfilter/inference_backend/pre_proc.h b/libavfilter/inference_backend/pre_proc.h
new file mode 100644
index 0000000..9874b73
--- /dev/null
+++ b/libavfilter/inference_backend/pre_proc.h
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#pragma once
+
+#include "config.h"
+#include "image.h"
+
+typedef struct PreProcContext PreProcContext;
+
+typedef struct PreProc {
+    /* image pre processing module name. Must be non-NULL and unique among pre processing modules. */
+    const char *name;
+
+    void (*Destroy)(PreProcContext *context);
+
+    void (*Convert)(PreProcContext *context, const Image *src, Image *dst, int bAllocateDestination);
+
+    // to be called if Convert called with bAllocateDestination = true
+    void (*ReleaseImage)(PreProcContext *context, const Image *dst);
+
+    MemoryType mem_type;
+
+    int priv_size; ///< size of private data to allocate for pre processing
+} PreProc;
+
+struct PreProcContext {
+    const PreProc *pre_proc;
+    void *priv;
+};
+
+int GetPlanesCount(int fourcc);
+
+const PreProc *pre_proc_get_by_name(const char *name);
+
+const PreProc *pre_proc_get_by_type(MemoryType type);
+
+PreProcContext *pre_proc_alloc(const PreProc *pre_proc);
+
+void pre_proc_free(PreProcContext *context);
\ No newline at end of file
diff --git a/libavfilter/inference_backend/queue.c b/libavfilter/inference_backend/queue.c
new file mode 100644
index 0000000..8449c11
--- /dev/null
+++ b/libavfilter/inference_backend/queue.c
@@ -0,0 +1,151 @@
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+typedef struct _queue_entry queue_entry_t;
+typedef struct _queue queue_t;
+
+struct _queue_entry {
+    void *value;
+    queue_entry_t *prev;
+    queue_entry_t *next;
+    queue_t *queue;
+};
+
+struct _queue {
+    queue_entry_t *head;
+    queue_entry_t *tail;
+    size_t length;
+};
+
+static inline queue_entry_t *create_entry(queue_t *q) {
+    queue_entry_t *new_entry = (queue_entry_t *)calloc(1, sizeof(queue_entry_t));
+
+    assert(new_entry != NULL);
+
+    new_entry->queue = q;
+    return new_entry;
+}
+
+static queue_entry_t *queue_iterate(queue_t *q) {
+    queue_entry_t *it = q->head->next;
+    return it == q->tail ? NULL : it;
+}
+
+static queue_entry_t *queue_iterate_next(queue_t *q, queue_entry_t *it) {
+    queue_entry_t *next = it->next;
+    return next == q->tail ? NULL : next;
+}
+
+static void *queue_iterate_value(queue_entry_t *it) {
+    return it->value;
+}
+
+static queue_t *queue_create(void) {
+    queue_t *q = (queue_t *)malloc(sizeof(queue_t));
+    if (!q)
+        return NULL;
+
+    memset(q, 0, sizeof(queue_t));
+    q->head = create_entry(q);
+    q->tail = create_entry(q);
+    q->head->next = q->tail;
+    q->tail->prev = q->head;
+    q->head->prev = NULL;
+    q->tail->next = NULL;
+
+    return q;
+}
+
+static void queue_destroy(queue_t *q) {
+    queue_entry_t *entry;
+    if (!q)
+        return;
+
+    entry = q->head;
+    while (entry != NULL) {
+        queue_entry_t *temp = entry;
+        entry = entry->next;
+        free(temp);
+    }
+
+    q->head = NULL;
+    q->tail = NULL;
+    q->length = 0;
+    free(q);
+}
+
+static size_t queue_count(queue_t *q) {
+    return q ? q->length : 0;
+}
+
+static void queue_push_front(queue_t *q, void *val) {
+    queue_entry_t *new_node = create_entry(q);
+    queue_entry_t *original_next = q->head->next;
+
+    new_node->value = val;
+
+    q->head->next = new_node;
+    original_next->prev = new_node;
+    new_node->prev = q->head;
+    new_node->next = original_next;
+    q->length++;
+}
+
+static void queue_push_back(queue_t *q, void *val) {
+    queue_entry_t *new_node = create_entry(q);
+    queue_entry_t *original_prev = q->tail->prev;
+
+    new_node->value = val;
+
+    q->tail->prev = new_node;
+    original_prev->next = new_node;
+    new_node->next = q->tail;
+    new_node->prev = original_prev;
+    q->length++;
+}
+
+static void *queue_pop_front(queue_t *q) {
+    queue_entry_t *front = q->head->next;
+    queue_entry_t *new_head_next = front->next;
+    void *ret = front->value;
+
+    if (q->length == 0)
+        return NULL;
+
+    q->head->next = new_head_next;
+    new_head_next->prev = q->head;
+    free(front);
+    q->length--;
+    return ret;
+}
+
+static void *queue_pop_back(queue_t *q) {
+    queue_entry_t *back = q->tail->prev;
+    queue_entry_t *new_tail_prev = back->prev;
+    void *ret = back->value;
+
+    if (q->length == 0)
+        return NULL;
+
+    q->tail->prev = new_tail_prev;
+    new_tail_prev->next = q->tail;
+    free(back);
+    q->length--;
+    return ret;
+}
+
+static void *queue_peek_front(queue_t *q) {
+    if (!q || q->length == 0)
+        return NULL;
+
+    return q->head->next->value;
+}
+
+static void *queue_peek_back(queue_t *q) {
+    if (!q || q->length == 0)
+        return NULL;
+
+    return q->tail->prev->value;
+}
diff --git a/libavfilter/inference_backend/safe_queue.c b/libavfilter/inference_backend/safe_queue.c
new file mode 100644
index 0000000..3f599a7
--- /dev/null
+++ b/libavfilter/inference_backend/safe_queue.c
@@ -0,0 +1,145 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#include "safe_queue.h"
+#include <assert.h>
+#include <pthread.h>
+#include <stdlib.h>
+
+#include "queue.c"
+
+#define mutex_t pthread_mutex_t
+#define cond_t pthread_cond_t
+
+#define mutex_init(m) pthread_mutex_init((m), NULL)
+
+#define mutex_lock pthread_mutex_lock
+#define mutex_unlock pthread_mutex_unlock
+#define mutex_destroy pthread_mutex_destroy
+
+#define cond_init(c) pthread_cond_init((c), NULL)
+#define cond_signal pthread_cond_signal
+#define cond_broadcast pthread_cond_broadcast
+#define cond_wait pthread_cond_wait
+#define cond_destroy pthread_cond_destroy
+
+struct _SafeQueue {
+    queue_t *q;
+
+    mutex_t mutex;
+    cond_t cond;
+};
+
+SafeQueueT *SafeQueueCreate() {
+    SafeQueueT *sq = (SafeQueueT *)malloc(sizeof(SafeQueueT));
+    if (!sq)
+        return NULL;
+
+    sq->q = queue_create();
+    assert(sq->q);
+
+    mutex_init(&sq->mutex);
+    cond_init(&sq->cond);
+    return sq;
+}
+
+void SafeQueueDestroy(SafeQueueT *sq) {
+    if (!sq)
+        return;
+
+    mutex_lock(&sq->mutex);
+    queue_destroy(sq->q);
+    mutex_unlock(&sq->mutex);
+
+    mutex_destroy(&sq->mutex);
+    cond_destroy(&sq->cond);
+    free(sq);
+}
+
+void SafeQueuePush(SafeQueueT *sq, void *t) {
+    mutex_lock(&sq->mutex);
+    queue_push_back(sq->q, t);
+    cond_signal(&sq->cond);
+    mutex_unlock(&sq->mutex);
+}
+
+void SafeQueuePushFront(SafeQueueT *sq, void *t) {
+    mutex_lock(&sq->mutex);
+    queue_push_front(sq->q, t);
+    cond_signal(&sq->cond);
+    mutex_unlock(&sq->mutex);
+}
+
+void *SafeQueueFront(SafeQueueT *sq) {
+    void *value;
+    mutex_lock(&sq->mutex);
+    while (queue_count(sq->q) == 0) {
+        cond_wait(&sq->cond, &sq->mutex);
+    }
+    value = queue_peek_front(sq->q);
+    mutex_unlock(&sq->mutex);
+    return value;
+}
+
+void *SafeQueuePop(SafeQueueT *sq) {
+    void *value;
+    mutex_lock(&sq->mutex);
+    while (queue_count(sq->q) == 0) {
+        cond_wait(&sq->cond, &sq->mutex);
+    }
+    value = queue_pop_front(sq->q);
+    cond_signal(&sq->cond);
+    mutex_unlock(&sq->mutex);
+    return value;
+}
+
+int SafeQueueEmpty(SafeQueueT *sq) {
+    int empty = 0;
+    mutex_lock(&sq->mutex);
+    empty = (queue_count(sq->q) == 0);
+    mutex_unlock(&sq->mutex);
+    return empty;
+}
+
+void SafeQueueWaitEmpty(SafeQueueT *sq) {
+    mutex_lock(&sq->mutex);
+    while (queue_count(sq->q) != 0) {
+        cond_wait(&sq->cond, &sq->mutex);
+    }
+    mutex_unlock(&sq->mutex);
+}
+
+#if 0
+
+#include <stdio.h>
+
+int main(int argc, char *argv[])
+{
+    SafeQueueT *queue = SafeQueueCreate();
+
+    char TEST[] = {'A', 'B', 'C', 'D'};
+
+    SafeQueuePush(queue, (void *)&TEST[0]);
+    SafeQueuePush(queue, (void *)&TEST[1]);
+    SafeQueuePush(queue, (void *)&TEST[2]);
+    SafeQueuePush(queue, (void *)&TEST[3]);
+
+    SafeQueuePushFront(queue, (void *)&TEST[0]);
+    SafeQueuePushFront(queue, (void *)&TEST[1]);
+    SafeQueuePushFront(queue, (void *)&TEST[2]);
+    SafeQueuePushFront(queue, (void *)&TEST[3]);
+
+    while (!SafeQueueEmpty(queue))
+    {
+        char *c = (char *)SafeQueueFront(queue);
+        printf("%c\n", *c);
+        c = SafeQueuePop(queue);
+    }
+
+    SafeQueueDestroy(queue);
+    return 0;
+}
+#endif
diff --git a/libavfilter/inference_backend/safe_queue.h b/libavfilter/inference_backend/safe_queue.h
new file mode 100644
index 0000000..958c406
--- /dev/null
+++ b/libavfilter/inference_backend/safe_queue.h
@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * SPDX-License-Identifier: MIT
+ ******************************************************************************/
+
+#ifndef __SAFE_QUEUE_H
+#define __SAFE_QUEUE_H
+
+typedef struct _SafeQueue SafeQueueT;
+
+SafeQueueT *SafeQueueCreate(void);
+
+void SafeQueueDestroy(SafeQueueT *sq);
+
+void SafeQueuePush(SafeQueueT *sq, void *t);
+
+void SafeQueuePushFront(SafeQueueT *sq, void *t);
+
+void *SafeQueueFront(SafeQueueT *sq);
+
+void *SafeQueuePop(SafeQueueT *sq);
+
+int SafeQueueEmpty(SafeQueueT *sq);
+
+void SafeQueueWaitEmpty(SafeQueueT *sq);
+
+#endif // __SAFE_QUEUE_H
-- 
2.7.4

